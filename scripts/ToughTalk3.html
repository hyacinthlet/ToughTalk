<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>嗯聊3.0</title>
		<style>
			* {
				font-family: "微软雅黑";
			}
			
			.hidden {
				display: none;
			}
			
			*[hidden] {
				display: none;
			}
			
			input, textarea, select {
				display: inline-block;
				box-sizing: border-box;
				margin: 0 10px 10px 0;
				padding: 6px 12px;
				line-height: 26px;
				border: #999 1px solid;
				border-radius: 9px;
				background-color: #fff;
				color: #999;
				font-size: 18px;
				outline: none;
				transition: all 0.3s;
				outline: none;
			}
			input[type="text"] {
				width: 300px;
				height: 40px;
			}
			input[type="number"] {
				width: 100px;
				height: 40px;
			}
			input[type="file"] {
				margin: 0 0 14px;
				padding: 0;
				width: 100%;
				border: none;
				border-radius: 0;
				background-color: none;
			}
			textarea {
				width: 100%;
				height: 120px;
				resize: none;
			}
			input:focus, textarea:focus, select:focus {
				border-color: #fb2;
				color: #666;
			}
			
			.form {
				box-sizing: border-box;
				border: #999 1px dashed;
				border-radius: 12px;
				padding: 6px 20px;
			}
			
			.scroll_container {
				overflow-x: hidden;
				overflow-y: scroll;
			}
			.scroll_container::-webkit-scrollbar {
				width: 16px;
				border: none;
				border-radius: 8px;
				background-color: #fff;
			}
			.scroll_container::-webkit-scrollbar-thumb {
				border-radius: 8px;
				background-color: #666;
			}
			
			#container, #picture_preview {
				box-sizing: border-box;
				margin: 0 auto 500px;
				width: 800px;
				overflow: visible;
				position: relative;
			}
			#container_content {
				background-color: #eee;
				width: 800px;
				min-height: 600px;
				position: relative;
			}
			#container[type="limited"] #container_content {
				width: 816px;
				height: 1400px;
				overflow-y: scroll;
			}
			#container_content> div {
				box-sizing: border-box;
				width: 800px;
				padding: 40px 0;
			}
			#container[type="limited"] #container_content> div {
				padding-top: 80px;
			}
			#container_head {
				display: none;
				width: 800px;
				height: 100px;
				font-size: 24px;
				line-height: 100px;
				letter-spacing: 1px;
				text-align: center;
				background-color: #fffb;
				position: absolute;
				top: 0;
			}
			#container[type="limited"] #container_head {
				display: initial;
				width: 804px;
			}
			.item {
				box-sizing: border-box;
				margin: 20px 30px;
				min-width: 20px;
				border: #fff0 2px solid;
				position: relative;
				letter-spacing: 1px;
				transition: 0.2s all;
			}
			.item[side="right"] {
				text-align: right;
			}
			.item:hover {
				border-color: #fff;
			}
			.item[selected] {
				border-color: #fb2;
			}
			.talk_icon {
				display: inline-block;
				box-sizing: border-box;
				width: 80px;
				height: 80px;
				background-color: #fff;
				border-radius: 60px;
				position: absolute;
			}
			.item[side="right"]> .talk_icon {
				right: 0px;
			}
			#container .talk_name {
				display: inline-block;
				height: 24px;
				color: #666;
				font-weight: bold;
				font-size: 18px;
				line-height: 24px;
				position: absolute;
				top: 6px;
			}
			.item[side="left"]> .talk_name {
				left: 106px;
			}
			.item[side="right"]> .talk_name {
				right: 106px;
			}
			.talk_prefix {
				display: inline-block;
				width: 10px;
				height: 10px;
				border-radius: 2px;
				background-color: #999;
				transform: rotateZ(45deg);
				position: absolute;
				top: 52px;
			}
			.item[side="left"]> .talk_prefix {
				left: 94px;
			}
			.item[side="right"]> .talk_prefix {
				right: 94px;
				background-color: #8298b0;
			}
			.talk_container {
				display: inline-block;
				box-sizing: border-box;
				max-width: 100%;
				vertical-align: text-top;
				position: relative;
			}
			.talk_container> div {
				display: inline-block;
				box-sizing: border-box;
				max-width: 100%;
			}
			.talk_container> div:not(:first-of-type):not([style]) {
				margin-top: 8px;
			}
			.talk_container> div[bubble] {
				background-color: #ccc;
				border-radius: 8px;
				padding: 8px 16px;
			}
			.item[side="right"]> .talk_container> div[bubble] {
				background-color: #bcd;
			}
			.item[side="left"]> .talk_container {
				padding: 34px 100px 0 98px;
				text-align: left;
			}
			.item[side="right"]> .talk_container {
				padding: 34px 98px 0 100px;
				text-align: right;
			}
			.item[side="right"]> .talk_container> div> * {
				text-align: left;
			}
			.item[side="mid"]> .talk_container {
				padding: 0 80px;
				width: 100%;
				text-align: center; 
				color: #666;
			}
			.talk_container> div> * {
				display: inline-block;
				box-sizing: content-box;
				max-width: 100%;
				font-size: 24px;
				line-height: 30px;
				vertical-align: top;
				word-break: break-all;
			}
			.talk_container *[content-type="text"] {
				min-width: 20px;
				min-height: 30px;
			}
			.talk_container *[content-type="image"] {
				min-width: 50px;
				min-height: 50px;
				max-height: 500px;
				border: none;
				border-radius: 8px;
			}
			.talk_container *[content-type="audio"] {
				margin: -4px 0;
				padding-right: 6px;
				max-width: 100%;
				overflow-y: hidden;
			}
			.talk_container *[content-type="audio_duration"] {
				min-width: 20px;
				min-height: 30px;
			}
			.talk_container *[content-type="audio_translate"] {
				display: inline-block;
				min-width: 20px;
				min-height: 30px;
				margin-right: auto;
				color: #0006;
			}
			.talk_container *[content-type="audio"] div {
				display: inline-block;
				margin: 0 3px;
				width: 3px;
				border-radius: 3px;
				height: 100px;
				background-color: #fff;
				vertical-align: middle;
			}
			.talk_container *[content-type="audio"] div:nth-child(12n + 1) {
				height: 10px;
			}
			.talk_container *[content-type="audio"] div:nth-child(12n + 2) {
				height: 16px;
			}
			.talk_container *[content-type="audio"] div:nth-child(12n + 3) {
				height: 24px;
			}
			.talk_container *[content-type="audio"] div:nth-child(12n + 4) {
				height: 16px;
			}
			.talk_container *[content-type="audio"] div:nth-child(12n + 5) {
				height: 22px;
			}
			.talk_container *[content-type="audio"] div:nth-child(12n + 6) {
				height: 36px;
			}
			.talk_container *[content-type="audio"] div:nth-child(12n + 7) {
				height: 20px;
			}
			.talk_container *[content-type="audio"] div:nth-child(12n + 8) {
				height: 14px;
			}
			.talk_container *[content-type="audio"] div:nth-child(12n + 9) {
				height: 8px;
			}
			.talk_container *[content-type="audio"] div:nth-child(12n + 10) {
				height: 6px;
			}
			.talk_container *[content-type="audio"] div:nth-child(12n + 11) {
				height: 14px;
			}
			.talk_container *[content-type="audio"] div:nth-child(12n) {
				height: 24px;
			}
			.talk_container *[content-type="option"] {
				margin: 0;
				padding: 12px 24px;
				border: 1px solid #666;
				border-radius: 8px;
				background-color: #fff;
				color: #000;
			}
			.talk_container *[content-type="option"] div {
				margin: 0;
				padding: 6px 16px;
				border-radius: 4px;
				background-color: #ccc;
			}
			
			#scene_container {
				margin: 0 auto;
				width: 96vmin;
				height: 54vmin;
				position: relative;
				overflow: hidden;
				user-select: none;
				container-type: size;
			}
			#scene_container> div:first-of-type {
				font-size: 1.8cqw;
				width: 100%;
				max-height: 100%;
				aspect-ratio: 16 / 9;
				position: relative;
				transform: translateY(-50%);
				overflow: hidden;
				top: 50%;
			}
			#scene_container img {
				position: absolute;
			}
			#scene_background {
				width: 100%;
				height: 100%;
				background-color: #000;
				position: absolute;
				transform: translateY(-50%);
				top: 50%;
			}
			#scene_option {
				width: 100%;
				height: 100%;
				position: absolute;
				overflow: hidden;
			}
			#scene_chapter_view {
				width: 100%;
				height: 100%;
				background-color: #000a;
				position: absolute;
				overflow: hidden;
			}
			#scene_chapter_view .viewport {
				width: 100%;
				height: 100%;
				position: absolute;
				overflow: hidden;
			}
			#scene_chapter_view .content div[locked] {
				opacity: 0.4;
			}
			#scene_option> div, #scene_chapter_view .content div {
				position: absolute;
				transform: translateY(-50%);
				cursor: pointer;
			}
			#scene_chapter_view .content span {
				position: absolute;
				background-color: #fff;
				pointer-events: none;
			}
			#scene_chapter_view p {
				overflow-x: hidden;
				word-break: keep-all;
				font-size: 1em;
			}
			#scene_option img {
				width: 100%;
				opacity: 0.7;
				position: relative;
				transition: all 0.3s;
			}
			#scene_chapter_view img {
				width: 100%;
				opacity: 0.7;
				position: relative;
				transform: translateY(-50%);
				top: 50%;
				vertical-align: top;
				transition: all 0.3s;
			}
			#scene_option> div:hover img, #scene_chapter_view .content div:hover img {
				opacity: 1;
			}
			#scene_option p, #scene_chapter_view p {
				margin: 0;
				padding: 0;
				width: 100%;
				color: #fff;
				text-align: center;
				text-shadow: #000 0 0 0.2em;
				position: absolute;
				top: 50%;
				transform: translateY(-50%);
			}
			#scene_container .talk_base {
				width: 100%;
				height: 10em;
				background-image: linear-gradient(0deg, #000f, #0000);
				position: absolute;
				bottom: 0;
			}
			#scene_container .talk_name {
				box-sizing: border-box;
				width: 100%;
				height: 1.3em;
				color: #fff;
				font-size: 1.6em;
				font-weight: bold;
				letter-spacing: 0.1em;
				text-shadow: #000 0 0 0.2em;
				position: absolute;
				padding: 0 5%;
				bottom: 4em;
			}
			#scene_container .talk_container {
				box-sizing: border-box;
				width: 100%;
				height: 4.5em;
				color: #fff;
				font-size: 1em;
				letter-spacing: 0.1em;
				text-shadow: #000 0 0 0.2em;
				position: absolute;
				padding: 0 5%;
				bottom: 1.5em;
			}
			#scene_tool {
				box-sizing: border-box;
				list-style: none;
				margin: 0;
				padding: 0;
				width: 100%;
				color: #fff;
				font-size: 0.8em;
				letter-spacing: 0.1em;
				position: absolute;
				padding: 0 5%;
				bottom: 1em;
			}
			#scene_tool li {
				float: right;
				margin: 0 1em;
				opacity: 0.4;
				cursor: pointer;
				transition: opacity 0.3s, color 0.3s;
			}
			#scene_tool li[selected] {
				color: #fb2;
			}
			#scene_tool li:hover {
				opacity: 1;
			}
			#scene_ui {
				width: 100%;
				height: 100%;
				position: absolute;
			}
			#scene_cover {
				width: 100%;
				height: 100%;
				position: absolute;
				background-color: #fff;
				font-size: 0.9em;
				box-sizing: border-box;
				border: 0.3em solid #999;
			}
			#scene_cover ul {
				display: inline-block;
				margin: 0;
				padding: 0;
				width: 100%;
				list-style: none;
				text-align: center;
				position: relative;
				top: 5%;
			}
			#scene_cover li {
				margin: 0.7em 0;
				padding: 0;
				color: #666;
				letter-spacing: 0.1em;
			}
			#scene_cover p {
				margin: 0;
				padding: 0;
				font-size: 1.2em;
				letter-spacing: 0.1em;
				line-height: 1em;
			}
			#scene_cover input {
				margin: 0;
				padding: 0;
				width: 30%;
				font-size: 1.2em;
				letter-spacing: 0.1em;
				line-height: 1em;
				background-color: #ddd;
			}
			#scene_cover button {
				font-size: 1.2em;
				letter-spacing: 0.1em;
				line-height: 1em;
				padding: 0.4em 0.8em;
				border: 0.1em solid #666;
				border-radius: 2em;
				background-color: #fff;
				cursor: pointer;
				transition: all 0.3s;
			}
			#scene_cover button:hover {
				color: #fff;
				background-color: #666;
			}
			.viewport {
				overflow: hidden;
			}
			.scroll_slot {
				border: 0.1em solid #fff6;
				background-color: #0006;
				position: absolute;
				user-select: none;
				opacity: 0.3;
				transition: opacity 0.6s;
				transition-delay: 3s;
			}
			.scroll_slot:hover {
				opacity: 1;
				transition: opacity 0.1s;
				transition-delay: 0s;
			}
			.scroll_bar {
				border: none;
				background-color: #fb2;
				position: relative;
				transform: translate(-50%,-50%);
				user-select: none;
				cursor:pointer;
			}
			#scene_history {
				width: 100%;
				height: 100%;
				position: absolute;
				background-color: #000a;
			}
			.talk_history {
				display: inline-block;
				width: 100%;
				list-style: none;
				color: #fff;
				margin: 0;
				padding: 4em 0 0;
				pointer-events: none;
			}
			.talk_history li {
				margin: 0.7em 0;
				padding: 0;
				line-height: 1.3em;
				overflow: hidden;
			}
			.talk_history h3 {
				display: inline-block;
				margin: 0 3% 0 10%;
				padding: 0;
				width: 20%;
				font-size: 1em;
				letter-spacing: 0.1em;
				font-weight: bold;
				text-align: right;
				vertical-align: top;
			}
			.talk_history p {
				display: inline-block;
				margin: 0;
				padding: 0;
				width: 50%;
				font-size: 1em;
				letter-spacing: 0.1em;
				text-align: left;
				vertical-align: top;
			}
			#scene_pop_note {
				display: block;
				width: 20%;
				height: 15%;
				padding: 0.8em;
				border-top: 0.2em solid #fff6;
				background-color: #000a;
				position: absolute;
				bottom: 0;
				right: 0;
				color: #fff;
				transition: bottom 0.5s;
			}
			#scene_pop_note[hidden] {
				bottom: -30%;
			}
			#scene_pop_note h3 {
				margin: 0 0 0.5em;
				padding: 0;
				font-size: 1em;
				letter-spacing: 0.1em;
				font-weight: bold;
			}
			#scene_pop_note p {
				margin: 0;
				padding: 0;
				font-size: 1em;
				letter-spacing: 0.1em;
			}
			
			#control {
				box-sizing: border-box;
				padding: 30px;
				border: #999 2px solid;
				border-radius: 16px;
				background-color: #fffb; 
				box-shadow: #aaa 0 0 20px;
				font-size: 20px;
				position: fixed;
				top: 80px;
				left: 80px;
				user-select: none;
				transition: width 0.3s, height 0.3s;
			}
			#control[type="0"] {
				width: 10px;
				height: 10px;
			}
			#control[type="0"] #debug_panel {
				display: none;
			}
			#control[type="1"] {
				width: 600px;
				height: 800px;
			}
			#control[type="2"] {
				width: 1200px;
				height: 900px;
			}
			#control h3 {
				padding-left: 8px;
				border-left: #fb2 8px solid;
				font-size: 20px;
			}
			#control h4 {
				margin: 10px 0 5px;
				padding-left: 10px;
				font-size: 18px;
				font-weight: normal;
			}
			#control h4 span {
				margin: 0 5px;
				padding: 0 5px;
				color: #666;
				border: #fb2 1px solid;
				border-radius: 4px;
			}
			#control_container {
				box-sizing: border-box;
				width: 100%;
				height: 100%;
				padding-right: 6px;
				padding-bottom: 260px;
				overflow-x: hidden;
				overflow-y: scroll;
			}
			#control[type="0"] #control_container {
				width: 0;
				height: 0;
				padding: 0;
			}
			#control_container h3> button {
				margin-left: 10px;
				width: 24px;
				height: 24px;
				border: none;
				border-radius: 24px;
				background-color: #fb2;
				font-weight: bold;
				cursor: pointer;
			}
			.button_list {
				display: inline-block;
				width: 100%;
				list-style: none;
				margin: 0;
				padding: 0;
			}
			.button_list li {
				float: left;
				margin: 0 10px 10px 0;
				padding: 6px 12px;
				height: 26px;
				line-height: 26px;
				border: #fb2 1px solid;
				border-radius: 9px;
				background-color: #fff;
				text-align: center;
				overflow: hidden;
				cursor: pointer;
				transition: all 0.3s;
			}
			.button_list li[type="red"] {
				border: #e54 1px solid;
			}
			.button_list li:hover, .button_list li[selected] {
				background-color: #fb2;
			}
			.button_list li[type="red"]:hover, .button_list li[type="red"][selected] {
				background-color: #e54;
				color: #fff;
			}
			.char_case {
				list-style: none;
				margin: 0;
				padding: 0;
				width: 100%;
			}
			.char_case li {
				display: inline-block;
				margin: 0 10px 10px 0;
				padding-top: 10px;
				width: 120px;
				height: 140px;
				border: 1px solid #aaa;
				border-radius: 12px;
				background-color: #fff;
				text-align: center;
				overflow: hidden;
			}
			.char_case img {
				box-sizing: border-box;
				width: 100px;
				height: 100px;
				border: #fff0 2px solid;
				border-radius: 100px;
				cursor: pointer;
			}
			.char_case li[selected] img {
				border-color: #fb2;
			}
			.char_case li p {
				margin: 0 auto;
				width: max-content;
			}
			.image_case {
				list-style: none;
				margin: 0;
				padding: 0;
				width: 100%;
			}
			.image_case li {
				display: inline-block;
				margin-bottom: 10px;
				width: 120px;
				text-align: center;
				overflow: hidden;
			}
			.image_case img {
				box-sizing: border-box;
				width: 100px;
				height: 100px;
				border: #fff0 2px solid;
				cursor: pointer;
			}
			.image_case li[selected] img {
				border-color: #fb2;
			}
			.image_case li p {
				margin: 0 auto;
				width: max-content;
			}
			#chapter_case {
				list-style: none;
				margin: 0;
				padding: 0;
				width: 100%;
			}
			#chapter_case li {
				display: inline-block;
				margin-bottom: 10px;
				padding: 6px 12px;
				text-align: center;
				overflow: hidden;
			}
			#chapter_case li[selected] {
				background-color: #fb2;
				border: none;
				border-radius: 9px;
			}
			#control_container .note {
				display: block;
				margin: 0 0 12px;
				padding: 0 6px;
				width: 60px;
				height: 24px;
				border: 1px solid #999;
				border-radius: 4px;
				background-color: #999;
				color: #fff;
				overflow: hidden;
				transition: all 0.3s;
			}
			#control_container .note:hover {
				width: unset;
				height: unset;
				border-color: #fb2;
				padding: 6px 12px;
				background-color: unset;
				color: #666;
			}
			#control_container .note> p {
				margin: 0 0 2px;
				padding: 0;
				border-bottom: 1px dashed #ddd;
				font-size: 18px;
				font-weight: normal;
			}
			#control_container .note:hover> p {
				padding: 2px 0;
			}
			#control_container .note> p> b {
				color: #333;
			}
			#render_output p {
				display: block;
				margin: 0;
				padding: 0;
				color: #333;
			}
			#render_output b {
				display: block;
				margin: 0;
				padding: 0;
				color: #e54;
				transform: translate();
			}
			
			#splash_introduction {
				width: 100%;
				height: 280px;
				padding-top: 0;
				color: #555;
				background: none;
				word-break: keep-all;
				text-align: center;
				position: fixed;
				/* color: #fff; */
				top: 200px;
				user-select: none;
				overflow: hidden;
				pointer-events: none;
			}
			#splash_introduction> div:first-of-type {
				width: 600%;
				height: 100%;
				position: absolute;
				left: -600%;
				transition: all 4s cubic-bezier(0, 0.4, 1, 0.6);
			}
			#splash_introduction> div[selected] {
				left: 100%;
			}
			#splash_introduction p:first-of-type {
				width: 100%;
				font-size: 120px;
				letter-spacing: 10px;
				position: absolute;
			}
			#splash_introduction p:last-of-type {
				width: 100%;
				font-size: 60px;
				position: absolute;
				letter-spacing: 6px;
				top: 50%;
			}
			#splash_introduction p {
				opacity: 1;
				transition: opacity 0.5s;
				transition-delay: 1s;
			}
			#splash_introduction p[selected] {
				color: #fff;
				top: 20%;
				opacity: 0;
			}
		</style>
		<script>
			var database = null;
			var control_panel = null;
			var scene_panel = null;
			var output_tool = null;
			var publicity_tool = null;
			const download_prefix = "el3";
			window.onload = function() {
				let data_container = document.getElementById("database");
				database = new d_Database();
				control_panel = new d_ControlPanel(document.getElementById("control"));
				output_tool = new d_HTML2Canvas();
				publicity_tool = new d_VersionPublicity();
				
				let jud = true;
				if (jud) {
					control_panel.loadData();
					// database.debug();
					return;
				}
				
				database.addRecord("talk", [9, "良穗相遇", "60", "", "0", "3000", "1"]);
				database.addRecord("talk", [6, "同生.png", "test1", "fill", "0", "2000", "cm"]);
				database.addRecord("talk", [7, "[话说回来，良爷觉得怎么样？]", "2", "talk_1.wav", "1", "0", "0"]);
				database.addRecord("talk", [2, "[什么怎么样？]", "test1", "test2", "test3", "", ""]);
				database.addRecord("talk", [7, "[你喜欢“满穗”，还是“穗”？]", "2", "talk_2.wav", "1", "0", "0"]);
				database.addRecord("talk", [2, "[……]", "test1", "", "test3", "", ""]);
				database.addRecord("talk", [1, "[……]", "test1", "", "test3", "", ""]);
				database.addRecord("talk", [2, "[……]", "test1", "", "test3", "", ""]);
				// 9
				database.addRecord("talk", [2, "[满穗吧……]", "test1", "", "test3", "", ""]);
				database.addRecord("talk", [1, "[……]", "test1", "", "test3", "", ""]);
				database.addRecord("talk", [2, "[我喜欢“满穗”。]", "", "test2", "", "", ""]);
				database.addRecord("talk", [3, "……", "test1", "", "test3", "", ""]);
				database.addRecord("talk", [7, "[哦……]", "0", "talk_3.wav", "1", "0", "0"]);
				database.addRecord("talk", [3, "……", "test1", "", "test3", "", ""]);
				// 15
				database.addRecord("talk", [2, "[满穗、满穗、满穗……]", "test1", "test2", "", "", ""]);
				database.addRecord("talk", [3, "我念了一遍又一遍她的名字。", "", "test2", "test3", "", ""]);
				database.addRecord("talk", [1, "[……]", "test1", "", "test3", "", ""]);
				database.addRecord("talk", [6, "小满穗.png", "test1", "origin", "1", "500", "cb"]);
				database.addRecord("talk", [3, "她没有说话，只是装着听不见我在念她的名字。", "", "test2", "test3", "", ""]);
				database.addRecord("talk", [6, "", "test1", "300", "1", "", ""]);
				database.addRecord("talk", [3, "她时不时地轻笑着，不知在高兴些什么。", "", "test2", "test3", "", ""]);
				
				database.addRecord("talk", [2, "[做个小测试]", "test1", "test2", "test3", "", ""]);
				
				database.addRecord("character", ["", "良"]);
				database.addRecord("character", ["", "满穗"]);
				database.addRecord("character", ["", ""]);
				
				database.addRecord("talk_character", [1, 3]);
				database.addRecord("talk_character", [2, 3]);
				database.addRecord("talk_character", [3, 2]);
				database.addRecord("talk_character", [4, 1]);
				database.addRecord("talk_character", [5, 2]);
				database.addRecord("talk_character", [6, 1]);
				database.addRecord("talk_character", [7, 2]);
				database.addRecord("talk_character", [8, 1]);
				database.addRecord("talk_character", [9, 1]);
				database.addRecord("talk_character", [10, 2]);
				database.addRecord("talk_character", [11, 1]);
				database.addRecord("talk_character", [12, 3]);
				database.addRecord("talk_character", [13, 2]);
				database.addRecord("talk_character", [14, 3]);
				database.addRecord("talk_character", [15, 1]);
				database.addRecord("talk_character", [16, 3]);
				database.addRecord("talk_character", [17, 2]);
				database.addRecord("talk_character", [18, 3]);
				database.addRecord("talk_character", [19, 3]);
				database.addRecord("talk_character", [20, 3]);
				database.addRecord("talk_character", [21, 3]);
				
				database.addRecord("talk_character", [22, 3]);
				
				// 2
				database.addRecord("chapter", ["良 序章 狼", ""]);
				database.addRecord("chapter", ["良 第一章 猫", ""]);
				database.addRecord("chapter", ["良 第二章 说话", ""]);
				database.addRecord("chapter", ["良 第三章 豚妖", ""]);
				database.addRecord("chapter", ["良 第四章 影子戏", ""]);
				database.addRecord("chapter", ["良 第五章 官兵", ""]);
				database.addRecord("chapter", ["良 第六章 荒村", ""]);
				database.addRecord("chapter", ["良 第七章 澡堂", ""]);
				database.addRecord("chapter", ["良 第八章 饿与恶", ""]);
				database.addRecord("chapter", ["良 第九章 选择", ""]);
				database.addRecord("chapter", ["良 第十章 煮肉", ""]);
				database.addRecord("chapter", ["良 第十一章 梦想", ""]);
				database.addRecord("chapter", ["良 第十二章 闯将", ""]);
				database.addRecord("chapter", ["良 第十三章 狼与良", ""]);
				database.addRecord("chapter", ["良 第十四章 礼物", ""]);
				database.addRecord("chapter", ["良 第十五章 烟火", ""]);
				// 18
				database.addRecord("chapter", ["穗 序章 家", ""]);
				database.addRecord("chapter", ["穗 第一章 猫、豚妖", ""]);
				database.addRecord("chapter", ["穗 第二章 影子戏", ""]);
				database.addRecord("chapter", ["穗 第三章 荷包", ""]);
				database.addRecord("chapter", ["穗 第四章 绝望", ""]);
				database.addRecord("chapter", ["穗 第五章 活着", ""]);
				database.addRecord("chapter", ["穗 第六章 逃荒", ""]);
				database.addRecord("chapter", ["穗 第七章 复仇", ""]);
				// 26
				database.addRecord("chapter", ["结局 半途而死 猫杀", ""]);
				database.addRecord("chapter", ["结局 半途而死 兵杀", ""]);
				database.addRecord("chapter", ["结局 半途而死 狼杀", ""]);
				database.addRecord("chapter", ["结局 半途而死 闯杀", ""]);
				database.addRecord("chapter", ["结局 半途而死 报应", ""]);
				// 31
				database.addRecord("chapter", ["结局 无言", ""]);
				database.addRecord("chapter", ["结局 快逃", ""]);
				database.addRecord("chapter", ["结局 不见", ""]);
				database.addRecord("chapter", ["结局 饿殍", ""]);
				let id = database.addRecord("chapter", ["真结局 同生", ""]);
				database.addRecord("chapter", ["真结局 共死", ""]);
				
				for (let i = 1; i <= 21; ++i) {
					database.addRecord("chapter_talk", [id, i]);
				}
				database.addRecord("chapter_talk", [1, 22]);
				
				let temp = "2,良 序章 狼,1;3,良 第一章 猫,2;26,结局 半途而死,,4,良 第二章 说话,1;";
				temp += "5,良 第三章 豚妖,1,18,穗 序章 家,;6,良 第四章 影子戏,2;27,结局 半途而死,,7,良 第五章 官兵,1;";
				temp += "8,良 第六章 荒村,1,19,穗 第一章 猫、豚妖,;9,良 第七章 澡堂,1;10,良 第八章 饿与恶,2,20,穗 第二章 影子戏,;";
				temp += "28,结局 狼杀,,11,良 第九章 选择,1;12,良 第十章 煮肉,1;13,良 第十一章 梦想,2,21,穗 第三章 荷包,;";
				temp += "29,结局 半途而死,,14,良 第十二章 闯将,2;30,结局 报应,,15,良 第十三章 狼与良,1;";
				temp += "16,良 第十四章 礼物,2,22,穗 第四章 绝望,;31,结局 无言,,17,良 第十五章 烟火,,23,穗 第五章 活着,;";
				temp += "32,结局 快逃,,24,穗 第六章 逃荒,;33,结局 不见,,34,结局 饿殍,,25,穗 第七章 复仇,;";
				temp += "35,真结局 同生,;36,真结局 共死,";
				
				
				database.update("advanced_param", "data=" + temp, "name=chapter_view");
				database.update("advanced_param", "data=章节视图选项.jpg", "name=chapter_view_resource");
				// console.log(database.select("talk", "*", "type=1"));
				// console.log(database.select("talk", "id,param1", "type=1"));
				// console.log(database.select("talk", "id,param1"));
				// console.log(database.select("talk", "*", "param2=1"));
				// console.log(database.select("talk", "id", "param2=test1"));
				// console.log(database.select("talk", "*", "param2=test1,param3=test2"));
				// console.log(database.select("talk", "*", "param2=test1,param3=test2,param4=test3"));
				// console.log(database.select("talk", "*", "param2=test1,param3=test2,param4=4"));
				// database.update("talk", "param4=hey,type=1", "param2=test1");
				// console.log(database.select("talk", "*", "param2=test1"));
				// console.log(database.getAllRecord("talk"));
				control_panel.loadData();
				database.debug();
			}
			
			// 二进制读取
			class d_BinaryReader {
				#index = 0;
				#data = null;
				#text_decoder = null;
				
				// 传入一个DataView对象
				constructor(data) {
					this.#data = data;
					this.#index = 0;
					this.#text_decoder = new TextDecoder("utf-8");
					// console.log(data)
				}
				
				getString() {
					let len = this.getNumber();
					if (len == null) {
						return null;
					}
					if (this.#index + len >= this.#data.length) {
						return null;
					}
					let arr = new Int8Array(len);
					for (let i = 0; i < arr.length; ++i) {
						arr[i] = this.#data.getInt8(this.#index);
						++this.#index;
					}
					let res = this.#text_decoder.decode(arr);
					return res;
				}
				
				getNumber() {
					if (this.#index + 4 >= this.#data.length) {
						return null;
					}
					let res = this.#data.getInt32(this.#index);
					this.#index += 4;
					return res;
				}
				
				getBool() {
					
				}
			}
			
			// 二进制写入
			class d_BinaryWriter {
				#data = null;
				#text_encoder = null;
				#buffer = null;
				#view = null;
				
				constructor() {
					this.#data = new Array();
					this.#text_encoder = new TextEncoder("utf-8");
					this.#buffer = new ArrayBuffer(4);
					this.#view = new DataView(this.#buffer);
				}
				
				addString(str) {
					let arr = this.#text_encoder.encode(str);
					this.addNumber(arr.length);
					for (let i = 0; i < arr.length; ++i) {
						this.#data.push(arr[i]);
					}
				}
				
				addNumber(str) {
					this.#view.setInt32(0, str);
					for (let i = 0; i < 4; ++i) {
						this.#data.push(this.#view.getInt8(i));
					}
				}
				
				append(other) {
					let arr = other.#data;
					for (let i = 0; i < arr.length; ++i) {
						this.#data.push(arr[i]);
					}
				}
				
				get() {
					return new Int8Array(this.#data);
				}
				
				getBlob() {
					// console.log(this.#data)
					return new Blob([new Int8Array(this.#data).buffer]);
				}
				
			}
			
			// 枚举
			class d_DataEnum {
				// talk data
				// id  类型
				
				// text
				// 内容
				static LEFT_TEXT = 1;
				static RIGHT_TEXT = 2;
				static MID_TEXT = 3;
				
				// image
				// 资源路径  大小  适应方式  图层号  过渡时间（毫秒）  对齐方式
				static LEFT_IMAGE = 4;
				static RIGHT_IMAGE = 5;
				static MID_IMAGE = 6;
				
				// audio
				// 文字描述  音频长度  资源路径  音轨号  过渡时间  循环
				static LEFT_AUDIO = 7;
				static RIGHT_AUDIO = 8;
				static MID_AUDIO = 9;
				
				// option
				// 文字描述  选项个数  资源路径  变量修饰  章节跳转  选项条件
				static OPTION = 10;
			}
			
			// 数据库
			class d_Database {
				// 调试信息输出开关
				static debug_mode = false;
				
				// 数据文本分割字符串
				static split_symbol = "/&";
				
				// 数据库版本
				static version = "3";
				
				// 附加数据
				#tag = "null";
				
				// 表
				#table = null;
				
				// 上次将数据存到localStorage的时间
				#lastSaveTime = "未保存";
				
				// 实例化对象后，先建立一个带表的空数据库，以便用户开始新作品的编辑
				constructor() {
					this.#constructEmpty();
				}
				
				// 建立一个带表的空数据库
				#constructEmpty() {
					let data = [
						["character", 3,  0, "id", 0, "path", 0, "name"],
						["talk", 8,  0, "id", 0, "type", 0, "param1", 0, "param2", 0, "param3", 0, "param4", 0, "param5", 0, "param6"],
						["talk_character", 3,  0, "id", 1, "id_t", 2, "id_c"],
						["chapter", 3,  0, "id", 0, "name", 0, "type", "1", "默认", "begin"],
						["chapter_talk", 3,  0, "id", 1, "id_c", 2, "id_t"],
						["advanced_param", 3,  0, "id", 0, "name", 0, "data", 1, "chapter_view", "", 2, "chapter_view_resource", ""],
						["resource", 3,  0, "id", 0, "type", 0, "data"]
					];
					let writer = new d_BinaryWriter();
					writer.addString(d_Database.version);
					writer.addNumber(data.length);
					for (let i = 0; i < data.length; ++i) {
						let data_slice = data[i];
						let loop = 0;
						writer.addString(data_slice[loop]);
						++loop;
						let field_count = data_slice[loop];
						writer.addNumber(field_count);
						let record_count = (data_slice.length - 2 - field_count * 2) / field_count;
						writer.addNumber(record_count);
						++loop;
						for (let j = 0; j < field_count; ++j) {
							writer.addNumber(data_slice[loop]);
							++loop;
							writer.addString(data_slice[loop]);
							++loop;
						}
						for ( ; loop < data_slice.length; ++loop) {
							writer.addString(data_slice[loop]);
						}
					}
					writer.addString("data");
					// console.log(writer);
					this.importBinaryData(writer.get().buffer);
				}
				
				// 从字符串中提取数据信息
				importData(data) {
					if (data == null || data.length == 0) {
						this.debugLogError("载入数据失败：空数据");
						return;
						// data = [
						// 	["character", 3,  0, 0, 0,  1, "1.png", "芬吸员",  2, "3.png", "铸币安卡"],
						// 	["talk", 4,  0, 0, 0, 0,  1, 7, "嗯嗯", 4,  2, 3, "22222222222222222222222222222222222222222222222222", 0,  3, 1, "第2222222222222222222222222222222222222222222222222222222222条", 0,  4, 1, "", 0],
						// 	["talk_character", 2,  0, 1,  1, 1,  2, 1,  3, 2,  4, 1],
						// 	// ["test", 4,  0, 0, 0, 0,  1, 1, "好啊", 0,  1, 1, "嗯嗯", 0],
						// 	// ["test2", 3,  0, 1, 0,  1, 1, "aa",  1, 2, "bb",  3, 2, "cc",  4, 3, "dd"]
						// ];
						// for (let i = 0; i < data.length; ++i) {
						// 	data[i] = data[i].join(d_DatabaseTable.split_symbol);
						// }
						// data = d_Database.version + d_Database.split_symbol + data.join(d_Database.split_symbol);
					}
					let str_data = data.split(d_Database.split_symbol);
					if (str_data.length == 0) {
						this.debugLogError("载入数据失败：数据格式有误");
						return;
					}
					if (d_Database.debug_mode) {
						this.debugLog("数据版本: " + str_data[0]);
					}
					if (str_data[0] != d_Database.version) {
						this.debugLogError("载入数据失败：数据版本不匹配");
						return;
					}
					this.#table = new Array();
					for (let i = 1; i < str_data.length; ++i) {
						let table = new d_DatabaseTable();
						// 数据有误，立即清空数据库
						if (!table.importData(str_data[i])) {
							this.#constructEmpty();
							this.debugLogError("载入数据失败：数据有误");
							return;
						}
						this.#table.push(table);
					}
					if (d_Database.debug_mode) {
						this.debugLog("加载共" + this.#table.length + "张表");
						// console.dir(this.#table);
					}
					
					// id为database的dom元素是开启debug后，用于展示数据库内容的
					document.getElementById("database").innerText = data;
				}
				
				// 从二进制数据中提取数据信息
				importBinaryData(data) {
					if (data == null || data.length == 0) {
						this.debugLogError("载入数据失败：空数据");
						return;
					}
					let reader = new d_BinaryReader(new DataView(data));
					let str_data = reader.getString();
					if (str_data.length == 0) {
						this.debugLogError("载入数据失败：数据格式有误");
						return;
					}
					if (d_Database.debug_mode) {
						this.debugLog("数据版本: " + str_data);
					}
					if (str_data != d_Database.version) {
						this.debugLogError("载入数据失败：数据版本不匹配");
						return;
					}
					this.#table = new Array(reader.getNumber());
					for (let i = 0; i < this.#table.length; ++i) {
						let table = new d_DatabaseTable();
						// 数据有误，立即清空数据库
						if (!table.importBinaryData(reader)) {
							this.#constructEmpty();
							this.debugLogError("载入数据失败：数据有误");
							return;
						}
						this.#table[i] = table;
					}
					if (d_Database.debug_mode) {
						this.debugLog("加载共" + this.#table.length + "张表");
						// console.dir(this.#table);
					}
					
					// id为database的dom元素是开启debug后，用于展示数据库内容的
					document.getElementById("database").innerText = data;
					
					this.#tag = reader.getString();
				}
				
				// 从文件中导入数据
				importDataFromFile(that) {
					var file = that.files[0];
					
					// 如果不是txt，就无法解析
					if (file == null || file.name.substr(file.name.lastIndexOf('.') + 1) != "txt") {
						this.debugLogError("文件格式有误");
						return;
					}
					var reader = new FileReader();
					reader.readAsText(file);
					reader.onload = function() {
						// 使用txt内文本进行数据库构建
						database.importData(reader.result);
						that.value = null;
						
						// 构建完成后，刷新视图
						control_panel.loadData();
					}
				}
				
				// 从二进制文件中导入数据
				importDataFromBinaryFile(that) {
					var file = that.files[0];
					
					// 如果不是.el，就无法解析
					if (file == null || file.name.substr(file.name.lastIndexOf('.') + 1) != "el") {
						this.debugLogError("文件格式有误");
						return;
					}
					var reader = new FileReader();
					reader.readAsArrayBuffer(file);
					reader.onload = function() {
						
						// database.temp_combine(reader.result);
						// return;
						
						// 使用txt内文本进行数据库构建
						database.importBinaryData(reader.result);
						that.value = null;
						
						// 构建完成后，刷新视图
						control_panel.loadData();
					}
				}
				
				// 将数据以文本形式导出，这些导出的数据符合导入的数据格式
				exportData() {
					let data = d_Database.version;
					for (let i = 0; i < this.#table.length; ++i) {
						data += d_Database.split_symbol + this.#table[i].exportData();
					}
					let link = document.createElement("a");
					link.download = download_prefix + "Data" + new Date().getTime();
					link.href = "data:text/plain;charset=utf-8," + data;
					link.click();
					link.remove();
				}
				
				// 将数据以二进制形式导出，这些导出的数据符合导入的数据格式
				exportBinaryData(tag, download) {
					let writer = new d_BinaryWriter();
					writer.addString(d_Database.version);
					writer.addNumber(this.#table.length);
					for (let i = 0; i < this.#table.length; ++i) {
						writer.append(this.#table[i].exportBinaryData());
					}
					if (tag == null) {
						tag = "data";
					}
					writer.addString(tag);
					
					if (download == true) {
						let link = document.createElement("a");
						link.download = download_prefix + tag + new Date().getTime() + ".el";
						link.href = window.URL.createObjectURL(writer.getBlob());
						link.click();
						link.remove();
					}
					return writer.get();
				}
				
				temp_combine(data) {
					let temp = new d_Database();
					temp.importBinaryData(data);
					for (let i = 0; i < 5; ++i) {
						this.#table[i] = temp.#table[i];
					}
					this.#table[6] = temp.#table[5];
					this.#table[6].name = "resource";
				}
				
				// 从表数组中找到指定名字的表，使用遍历方法
				#getTable(table_name) {
					for (let i = 0; i < this.#table.length; ++i) {
						if (this.#table[i].name == table_name) {
							return this.#table[i];
						}
					}
					return null;
				}
				
				getTag() {
					return this.#tag;
				}
				
				// 获得表的主键计数器
				// 如果要保证表主键不重复，需要在调用后手动给结果+1
				getPrimaryKeyCount(table_name) {
					let table = this.#getTable(table_name);
					if (table == null) {
						return -1;
					}
					return table.getPrimaryKeyCount();
				}
				
				// 获取指定表中指定键名的记录，返回一个数组
				// 其中key_id指明外键的编号，如果为零或小于零代表是主键
				getRecord(table_name, key, key_id) {
					let table = this.#getTable(table_name);
					if (table == null) {
						return null;
					}
					return table.getRecord(key, key_id);
				}
				
				// SELECT语句
				select(table_name, output, where) {
					let table = this.#getTable(table_name);
					if (table == null) {
						return null;
					}
					return table.op_select(output, where);
				}
				
				// UPDATE语句
				update(table_name, set, where) {
					let table = this.#getTable(table_name);
					if (table == null) {
						return null;
					}
					return table.op_update(set, where);
				}
				
				// 获取指定表的所有记录，返回一个二维数组
				getAllRecord(table_name) {
					let table = this.#getTable(table_name);
					if (table == null) {
						return null;
					}
					return table.getAllRecord();
				}
				
				// 变更某表记录的数据，如果无法根据key和key_id找到记录，则不做操作
				setRecord(table_name, key, data) {
					let table = this.#getTable(table_name);
					if (table == null) {
						return null;
					}
					return table.setRecord(key, data);
				}
				
				// 调整记录的顺序
				// 比如在调整聊天消息的顺序时，需要调整记录的顺序，下次读入的顺序也会变更
				// changeRecordIndex(table_name, key, offset) {
				// 	let table = this.#getTable(table_name);
				// 	if (table == null) {
				// 		return null;
				// 	}
				// 	return table.changeRecordIndex(key, offset);
				// }
				
				// 设置记录的顺序
				// 比如在调整聊天消息的顺序时，需要调整记录的顺序，下次读入的顺序也会变更
				// setRecordIndex(table_name, key, index) {
				// 	let table = this.#getTable(table_name);
				// 	if (table == null) {
				// 		return null;
				// 	}
				// 	return table.setRecordIndex(key, index);
				// }
				
				// 设置记录的顺序
				// 比如在调整聊天消息的顺序时，需要调整记录的顺序，下次读入的顺序也会变更
				swapRecordIndex(table_name, key_a, key_b) {
					let table = this.#getTable(table_name);
					if (table == null) {
						return null;
					}
					return table.swapRecordIndex(key_a, key_b);
				}
				
				// 增加一条记录
				addRecord(table_name, data) {
					let table = this.#getTable(table_name);
					if (table == null) {
						return -1;
					}
					return table.addRecord(data);
				}
				
				// 移出一条记录
				removeRecord(table_name, key, key_id) {
					let table = this.#getTable(table_name);
					if (table == null) {
						return;
					}
					table.removeRecord(key, key_id);
				}
				
				// 获取当前记录数目
				getRecordCount(table_name) {
					let table = this.#getTable(table_name);
					if (table == null) {
						return -1;
					}
					return table.getRecordCount();
				}
				
				// 将数据存到indexedDB中
				storeData() {
					// let data_container = document.getElementById("database");
					// let data = d_Database.version;
					// for (let i = 0; i < this.#table.length; ++i) {
					// 	data += d_Database.split_symbol + this.#table[i].exportData();
					// }
					// if (d_Database.debug_mode) {
					// 	this.debugLog("已存档：" + new Date());
					// }
					
					// data_container.innerText = data;
					// console.trace("save");
					let request = window.indexedDB.open("ELData", 1);
					let self = this;
					request.onsuccess = function(event) {
						let db = event.target.result;
						let transaction = db.transaction(["work_data"], "readwrite");
						let objectStore = transaction.objectStore("work_data");
						let data = {id: 1, data: self.exportBinaryData(null, false)};
						// localStorage.setItem("el_data", data);
						objectStore.put(data);
						let date = new Date();
						self.#lastSaveTime = date.getHours().toString().padStart(2, '0') + ":" + date.getMinutes().toString().padStart(2, '0') + ":" + date.getSeconds().toString().padStart(2, '0');
						control_panel.updateTip();
					};
					request.onupgradeneeded = function() {
						let db = event.target.result;
						let _object = db.createObjectStore("work_data", {keyPath: "id", autoIncrement: true});
						_object.createIndex("data", "data");
					};
				}
				
				// 从indexedDB中读出数据
				readDataFromDB() {
					let request = window.indexedDB.open("ELData", 1);
					let self = this;
					request.onsuccess = function(event) {
						let db = event.target.result;
						let transaction = db.transaction(["work_data"], "readwrite");
						let objectStore = transaction.objectStore("work_data");
						let request1 = objectStore.get(1);
						request1.onsuccess = function(event) {
							// console.log(request1.result.data.buffer)
							self.importBinaryData(request1.result.data.buffer);
							control_panel.loadData();
						};
					};
				}
				getLastSaveTime() {
					return this.#lastSaveTime;
				}
				debug() {
					console.log(this);
				}
				debugLog(str) {
					console.log("[Database] " + str);
				}
				debugLogError(str) {
					console.error("[Database] " + str);
				}
			}
			
			// 数据库表
			class d_DatabaseTable {
				static split_symbol = "&&";
				
				// 表名
				name = null;
				
				// 字段，使用key_id遍历字段确定外键所在列
				// key_id > 0 means key, first column means main key
				#field = null;
				
				// 字段名
				#field_tag = null;
				
				// 记录
				#record = null;
				
				// 外键映射表，通过外键key_id可以映射到所有的主键
				#key_map = null;
				
				// 表大小
				#size = null;
				
				// 主键计数器，只计算目前主键的最大值
				// 主键必须是数字
				#primaryKeyCount = null;
				
				// 从文本中提取数据信息
				importData(data) {
					if (data == null || data.length == 0) {
						return false;
					}
					data = data.split(d_DatabaseTable.split_symbol);
					if (data.length < 2) {
						return false;
					}
					
					// 第一段数据是表名
					this.name = data[0];
					
					// 第二段是字段数，确保是合法数字
					let temp_number = parseInt(data[1]);
					if (isNaN(temp_number) || temp_number < 0) {
						return false;
					}
					this.#size = {
						field_count: temp_number,
						record_count: 0,
						total: 0
					};
					let field_count = this.#size.field_count;
					let record_count = parseInt((data.length - field_count - 2) / this.#size.field_count);
					
					// 通过字段数和记录数推断数据长度是否合法
					if (data.length != 2 + field_count * (record_count + 1)) {
						return false;
					}
					
					// 数据合法，开始添加字段标记和记录
					this.#field = new Array(field_count);
					this.#record = new Map();
					this.#key_map = new Map();
					let offset = 2;
					for (let i = 0; i < field_count; ++i) {
						temp_number = parseInt(data[offset + i])
						if (isNaN(temp_number)) {
							return false;
						}
						this.#field[i] = temp_number;
					}
					offset += field_count;
					let len = record_count;
					for (let i = 0, j = 0; i < len; ++i) {
						let _arr = new Array(field_count);
						for (j = 0; j < field_count; ++j) {
							_arr[j] = data[offset + j];
						}
						this.addRecord(_arr);
						offset += this.#size.field_count;
					}
					
					if (d_Database.debug_mode) {
						database.debugLog("表" + this.name + "加载完毕，共" + this.#size.total + "项");
					}
					return true;
				}
				
				// 从二进制数据中提取数据信息
				importBinaryData(reader) {
					
					// 第一段数据是表名
					this.name = reader.getString();
					
					// 第二段是字段数，确保是合法数字
					let temp_number = reader.getNumber();
					if (isNaN(temp_number) || temp_number < 0) {
						return false;
					}
					this.#size = {
						field_count: temp_number,
						record_count: 0,
						total: 0
					};
					
					// 第三段是记录数，确保是合法数字
					temp_number = reader.getNumber();
					if (isNaN(temp_number) || temp_number < 0) {
						return false;
					}
					this.#size.record_count = temp_number;
					
					let field_count = this.#size.field_count;
					let record_count = this.#size.record_count;
					
					// 数据合法，开始添加字段标记和记录
					this.#field = new Array(field_count);
					this.#field_tag = new Array(field_count);
					this.#record = new Map();
					this.#key_map = new Map();
					
					// 字段和字段标记
					let offset = 2;
					for (let i = 0; i < field_count; ++i) {
						temp_number = reader.getNumber();
						if (isNaN(temp_number)) {
							return false;
						}
						this.#field[i] = temp_number;
						this.#field_tag[i] = reader.getString();
					}
					
					// 记录
					offset += field_count;
					let len = record_count;
					for (let i = 0, j = 0; i < len; ++i) {
						let _arr = new Array(field_count);
						for (j = 0; j < field_count; ++j) {
							_arr[j] = reader.getString();
						}
						this.addRecord(_arr);
						offset += this.#size.field_count;
					}
					
					if (d_Database.debug_mode) {
						database.debugLog("表" + this.name + "加载完毕，共" + this.#size.total + "项");
					}
					return true;
				}
				
				// 将表数据以文本形式导出，导出数据符合导入格式
				exportData() {
					let split_symbol = d_DatabaseTable.split_symbol;
					let data = this.name + split_symbol + this.#size.field_count;
					data += split_symbol + this.#field.join(d_DatabaseTable.split_symbol);
					let _record = this.getAllRecord();
					if (Array.isArray(_record[0])) {
						for (let i = 0; i < _record.length; ++i) {
							_record[i] = _record[i].join(d_DatabaseTable.split_symbol);
						}
					}
					data += split_symbol + _record.join(d_DatabaseTable.split_symbol);
					return data;
				}
				
				// 将表数据以二进制形式导出，导出数据符合导入格式
				exportBinaryData() {
					let writer = new d_BinaryWriter();
					writer.addString(this.name);
					writer.addNumber(this.#field.length);
					writer.addNumber(this.getRecordCount());
					for (let i = 0; i < this.#field.length; ++i) {
						writer.addNumber(this.#field[i]);
						writer.addString(this.#field_tag[i]);
					}
					let _record = this.getAllRecord();
					if (Array.isArray(_record[0])) {
						for (let i = 0; i < _record.length; ++i) {
							for (let j = 0; j < _record[i].length; ++j) {
								writer.addString(_record[i][j]);
							}
						}
					}
					else {
						for (let i = 0; i < _record.length; ++i) {
							writer.addString(_record[i]);
						}
					}
					return writer;
				}
				
				// 通过外键id和外键名查找对应的主键有什么
				// key_id 不大于0表示这就是主键，会检查主键合法性：是否是合法数字，是否存在
				getPrimaryKey(key, key_id) {
					key_id = parseInt(key_id);
					// 外键转主键
					if (key_id != null && key_id > 0) {
						key = key.toString();
						if (!this.#key_map.has(key_id)) {
							return null;
						}
						let id_map = this.#key_map.get(key_id);
						if (!id_map.has(key)) {
							return null;
						}
						key = id_map.get(key);
					}
					// 主键必须是数字
					else {
						key = parseInt(key);
						if (!this.#record.has(key)) {
							return null;
						}
					}
					// 结果既不是数字，也不是通过外键找到的主键数组，说明键非法
					if (isNaN(key) && !Array.isArray(key)) {
						return null;
					}
					return key;
				}
				
				// 获得主键在记录中的顺序下标
				// 因为不一定是顺序序列，所以通过顺序遍历查找
				getPrimaryKeyIndex(key) {
					key = this.getPrimaryKey(key, 0);
					if (key == null) {
						return -1;
					}
					let index = 0;
					let keys = this.#record.keys();
					for (let item of keys) {
						if (item == key) {
							break;
						}
						++index;
					}
					return index;
				}
				
				// 获得当前所有主键的最大数，将其+1后防止主键重复
				getPrimaryKeyCount() {
					if (this.#primaryKeyCount == null) {
						return 0;
					}
					return this.#primaryKeyCount;
				}
				
				// 通过键查找记录
				getRecord(key, key_id) {
					// 将键转主键
					key = this.getPrimaryKey(key, key_id);
					
					// 键不存在
					if (key == null) {
						return null;
					}
					let res = new Array();
					let value = null;
					
					// 如果是通过外键查找，可能会得到多个主键
					if (Array.isArray(key)) {
						for (let i = 0; i < key.length; ++i) {
							value = this.getRecord(key[i], 0);
							if (Array.isArray(value[0])) {
								for (let j = 0; j < value.length; ++j) {
									res.push(value[j]);
								}
							}
							else {
								res.push(value);
							}
						}
						return res;
					}
					// 如果是通过外键查找，可能会得到一个主键
					// 用主键查找，仅允许一个主键
					else {
						value = this.#record.get(key);
					}
					if (value == null) {
						return null;
					}
					
					// 如果主键对应的记录有多条，将它们拆散开来
					// if (Array.isArray(value[0])) {
					// 	for (let i = 0; i < value.length; ++i) {
					// 		let arr = new Array();
					// 		arr.push(key);
					// 		for (let j = 0; j < value[i].length; ++j) {
					// 			arr.push(value[i][j]);
					// 		}
					// 		res.push(arr);
					// 	}
					// }
					// 否则直接加上主键构成完整记录返回
					if (true) {
						res.push(key);
						for (let i = 0; i < value.length; ++i) {
							res.push(value[i]);
						}
					}
					return res;
				}
				
				// SELECT语句
				op_select(output, where) {
					let keys = this.#op_where(where);
					let res = new Array();
					for (let i = 0; i < keys.length; ++i) {
						res.push(this.getRecord(keys[i], 0));
					}
					res = this.#op_fieldSelect(output, res);
					return res;
				}
				
				// UPDATE语句
				op_update(set, where) {
					let keys = this.#op_where(where);
					this.#op_set(set, keys);
				}
				
				// 对列进行筛选
				#op_fieldSelect(output, data) {
					if (output == "*") {
						return data;
					}
					if (output == null || output.length == 0) {
						return [];
					}
					let query = d_Tool.splitString(output, ',');
					let res = new Array(data.length);
					for (let i = 0; i < data.length; ++i) {
						res[i] = new Array();
					}
					for (let i = 0; i < query.length; ++i) {
						let column_index = this.#fieldTagToIndex(query[i].trim());
						if (column_index < 0) {
							return [];
						}
						for (let j = 0; j < data.length; ++j) {
							res[j].push(data[j][column_index]);
						}
					}
					return res;
				}
				
				// where子语句，输出记录的主键
				// where - 格式为：字段名=值，多语句用逗号分隔
				// condition - 不需要传入该参数
				#op_where(where, conditions) {
					let res = new Array();
					if (where == null || where.length == 0) {
						res = Array.from(this.#record.keys());
						return res;
					}
					let query = d_Tool.splitString(where, ',');
					
					// 如果只有一个条件，就直接查
					if (query.length == 1) {
						// 0是列名，1是值
						let condition = [0, 0];
						let index = query[0].indexOf('=');
						if (index < 0) {
							return[];
						}
						condition[0] = query[0].substring(0, index).trim();
						condition[1] = query[0].substring(index + 1).trim();
						
						// 列序号
						index = this.#fieldTagToIndex(condition[0].trim());
						
						// 列名不存在
						if (index < 0) {
							return [];
						}
						
						// 在全部记录中查找
						let keys = conditions;
						// 在指定范围里查找
						if (conditions == null) {
							keys = Array.from(this.#record.keys());
						}
						
						// where指定的是主键，直接返回主键
						// if (index == 0) {
						// 	res = parseInt(condition[1]);
						// 	if (!isNaN(res)) {
						// 		return [];
						// 	}
						// 	else if (keys.includes(res)) {
						// 		return [res];
						// 	}
						// }
						
						for (let i = 0; i < keys.length; ++i) {
							let key = keys[i];
							let record = this.getRecord(key, 0);
							if (record[index].toString() == condition[1]) {
								res.push(key);
							}
						}
						// 符合where条件的结果的主键
						return res;
					}
					// 否则，递归查
					else {
						res = this.#op_where(query[0]);
						for (let i = 1; i < query.length; ++i) {
							res = this.#op_where(query[i], res);
							if (res.length == 0) {
								break;
							}
						}
					}
					return res;
				}
				
				// set子语句，改变指定主键的指定记录，不允许改变主键的值
				// set - 格式为：字段名=值，多语句用逗号分隔
				#op_set(set, keys) {
					if (set == null || set.length == 0) {
						return;
					}
					if (keys == null || keys.length == 0) {
						return;
					}
					let queue = d_Tool.splitString(set, ',');
					let conditions = new Array();
					for (let i = 0; i < queue.length; ++i) {
						let condition = [0, 0];
						let index = queue[i].indexOf('=');
						if (index < 0) {
							return;
						}
						condition[0] = queue[i].substring(0, index).trim();
						condition[1] = queue[i].substring(index + 1).trim();
						// if (condition.length != 2) {
						// 	return;
						// }
						// condition[0] = condition[0].trim();
						// condition[1] = condition[1].trim();
						index = this.#fieldTagToIndex(condition[0]);
						
						// 不允许改变主键
						if (index < 1) {
							return;
						}
						conditions.push(index);
						conditions.push(condition[1]);
					}
					
					for (let i = 0; i < keys.length; ++i) {
						let record = this.#record.get(keys[i]);
						for (let j = 0; j < conditions.length; j += 2) {
							record[conditions[j] - 1] = conditions[j + 1];
						}
						this.#record.set(keys[i], record);
					}
					return;
				}
				
				// 通过字段名查询其字段下标
				#fieldTagToIndex(tag) {
					for (let i = 0; i < this.#field_tag.length; ++i) {
						if (this.#field_tag[i] == tag) {
							return i;
						}
					}
					return -1;
				}
				
				// 获取所有记录，没什么好说的
				getAllRecord() {
					let keys = this.#record.keys();
					let res = new Array();
					for (let key of keys) {
						res.push(this.getRecord(key, 0));
						// let value = this.getRecord(key, 0);
						
						// // 主键对应记录有多条，将它们拆散
						// if (Array.isArray(value[0])) {
						// 	for (let j = 0; j < value.length; ++j) {
						// 		res.push(value[j]);
						// 	}
						// }
						// else {
						// 	res.push(value);
						// }
					}
					return res;
				}
				
				// 变更指定单个主键对应的记录
				// key必须是主键查找，并且data不包含主键
				setRecord(key, data) {
					if (data == null || data.length != this.#size.field_count - 1) {
						return;
					}
					
					// 检查主键合法性
					key = this.getPrimaryKey(key);
					if (key == null) {
						return;
					}
					if (Array.isArray(key)) {
						return;
					}
					let clone_data = Array.from(data);
					for (let i = 0; i < clone_data.length; ++i) {
						// 除主键外的数据都是字符串储存
						clone_data[i] = clone_data[i].toString();
					}
					let former_data = this.#record.get(key);
					for (let i = 0; i < clone_data.length; ++i) {
						if (this.#field[i + 1] <= 0) {
							continue;
						}
						if (former_data[i] == clone_data[i]) {
							continue;
						}
						// 如果外键变化，更改对应的键图
						let foreign_key = former_data[i];
						// 将原先外键对应的主键（数组）移除
						this.#removeForeignKey(foreign_key, this.#field[i + 1]);
						// 再将新外键记录
						this.#addForeignKey(clone_data[i], this.#field[i + 1], key);
					}
					this.#record.set(key, clone_data);
					// console.trace("success");
				}
				
				// 移动主键的顺序下标，没什么好说的
				// changeRecordIndex(key, offset) {
				// 	key = this.getPrimaryKey(key, 0);
				// 	if (key == null) {
				// 		return null;
				// 	}
				// 	let item_index = this.getPrimaryKeyIndex(key);
				// 	this.setRecordIndex(key, item_index + offset);
				// }
				
				// 设置主键的顺序下标，没什么好说的
				// setRecordIndex(key, new_index) {
				// 	alert("该函数已不允许使用");
				// 	key = this.getPrimaryKey(key, 0);
				// 	if (key == null) {
				// 		return null;
				// 	}
				// 	let item_index = this.getPrimaryKeyIndex(key);
					
				// 	if (new_index == "last") {
				// 		new_index = this.#size.record_count - 1;
				// 	}
				// 	else if (new_index < 0) {
				// 		new_index = 0;
				// 	}
				// 	else if (new_index >= this.#size.record_count) {
				// 		new_index = this.#size.record_count - 1;
				// 	}
				// 	if (item_index == new_index) {
				// 		return;
				// 	}
					
				// 	let new_map = new Map();
				// 	for (let item of this.#record.keys()) {
				// 		if (new_index == 0) {
				// 			new_map.set(key, this.#record.get(key));
				// 		}
				// 		if (key != item) {
				// 			new_map.set(item, this.#record.get(item));
				// 			--new_index;
				// 		}
				// 	}
				// 	if (new_index == 0) {
				// 		new_map.set(key, this.#record.get(key));
				// 	}
				// 	this.#record = new_map;
				// }
				
				// 交换主键的顺序下标，没什么好说的
				// 当条目超过10万时，性能消耗会比较显著
				swapRecordIndex(key_a, key_b) {
					key_a = this.getPrimaryKey(key_a, 0);
					if (key_a == null) {
						return null;
					}
					key_b = this.getPrimaryKey(key_b, 0);
					if (key_b == null) {
						return null;
					}
					let item_index_a = this.getPrimaryKeyIndex(key_a);
					let item_index_b = this.getPrimaryKeyIndex(key_b);
					
					let new_map = Array.from(this.#record);
					let swap = new_map[item_index_a];
					new_map[item_index_a] = new_map[item_index_b];
					new_map[item_index_b] = swap;
					this.#record = new Map();
					for (let i = 0; i < new_map.length; ++i) {
						this.#record.set(new_map[i][0], new_map[i][1]);
					}
				}
				
				// 增加一条记录
				// 如果这条记录的字段数等同于总字段数，则第一个字段视作主键
				// 如果这条记录的字段数等同于总字段数-1，则自动生成主键
				addRecord(data) {
					if (d_Database.debug_mode) {
						database.debugLog("添加数据：" + data);
					}
					if (data == null) {
						database.debugLogError("添加数据失败：数据为空");
						return -1;
					}
					
					let p_key = null;
					let clone_data = null;
					
					if (data.length == this.#size.field_count) {
						p_key = parseInt(data[0]);
						clone_data = data.slice(1);
					}
					else if (data.length == this.#size.field_count - 1) {
						p_key = this.getPrimaryKeyCount() + 1;
						clone_data = data.slice(0);
					}
					else {
						database.debugLogError("添加数据失败：数据格式错误");
						return -1;
					}
					
					if (isNaN(p_key)) {
						database.debugLogError("添加数据失败：数据ID错误");
						return -1;
					}
					
					// 更新主键计数器
					if (this.#primaryKeyCount == null) {
						this.#primaryKeyCount = p_key;
					}
					else if (this.#primaryKeyCount < p_key) {
						this.#primaryKeyCount = p_key;
					}
					
					for (let i = 0; i < clone_data.length; ++i) {
						clone_data[i] = clone_data[i].toString();
					}
					
					let value = null;
					// 如果已经存在主键，就报错
					if (this.#record.has(p_key)) {
						// let t_value = this.#record.get(key);
						// value = new Array();
						// value.push(t_value);
						// value.push(clone_data);
						database.debugLogError("添加数据失败：数据ID已存在");
						return -1;
					}
					else {
						value = clone_data;
					}
					this.#record.set(p_key, clone_data);
					
					// 更新表大小
					++this.#size.record_count;
					this.#size.total += this.#size.field_count;
					for (let i = 0; i < clone_data.length; ++i) {
						if (this.#field[i + 1] <= 0) {
							continue;
						}
						// 如果是外键，就加入记录
						this.#addForeignKey(clone_data[i], this.#field[i + 1], p_key);
					}
					return p_key;
				}
				
				// 通过外键key_id和键名foreign_key找到指定外键，为其添加一条主键映射
				#addForeignKey(foreign_key, key_id, primary_key) {
					key_id = parseInt(key_id);
					if (!this.#key_map.has(key_id)) {
						this.#key_map.set(key_id, new Map());
					}
					
					// 映射表首先通过key_id确定外键的列，再通过key键名确定外键的行
					let id_map = this.#key_map.get(key_id);
					let value = null;
					if (id_map.has(foreign_key)) {
						value = id_map.get(foreign_key);
						if (!Array.isArray(value)) {
							value = new Array();
							value.push(id_map.get(foreign_key));
						}
						value.push(primary_key);
					}
					else {
						value = primary_key;
					}
					id_map.set(foreign_key, value);
					this.#key_map.set(key_id, id_map);
				}
				
				// 移除一个外键
				#removeForeignKey(foreign_key, key_id) {
					key_id = parseInt(key_id);
					let id_map = this.#key_map.get(key_id);
					id_map.delete(foreign_key);
					// let value = id_map.get(foreign_key);
					// if (Array.isArray(value)) {
					// 	for (let i = 0; i < value.length; ++i) {
					// 		if (value[i] == key) {
					// 			value.splice(i, 1);
					// 			break;
					// 		}
					// 	}
					// 	if (value.length == 1) {
					// 		value = value[0];
					// 	}
					// 	id_map.set(foreign_key, value);
					// }
					// else {
					// 	id_map.delete(foreign_key);
					// }
					this.#key_map.set(key_id, id_map);
				}
				
				// 通过键移除一个记录
				removeRecord(key, key_id) {
					key = this.getPrimaryKey(key, key_id);
					if (key == null) {
						return null;
					}
					
					// 如果得到的是一个主键序列，就递归一次进行删除
					if (Array.isArray(key)) {
						for (let i = 0; i < key.length; ++i) {
							this.removeRecord(key[i], 0);
						}
					}
					else {
						let value = this.#record.get(key);
						let count = 1;
						
						// 主键对应有多条记录
						if (Array.isArray(value[0])) {
							count = value.length;
							for (let i = 1; i < this.#field.length; ++i) {
								// 如果字段大于0，表明这是外键，需要删除主键映射
								if (this.#field[i] <= 0) {
									continue;
								}
								for (let j = 0; j < value.length; ++j) {
									this.#removeForeignKey(value[j][i - 1], this.#field[i]);
								}
							}
						}
						for (let i = 0; i < value.length; ++i) {
							// 如果字段大于0，表明这是外键，需要删除主键映射
							if (this.#field[i + 1] > 0) {
								this.#removeForeignKey(value[i], this.#field[i + 1]);
							}
						}
						this.#record.delete(key);
						this.#size.record_count -= count;
						this.#size.total -= count * this.#size.field_count;
					}
				}
				
				// 获取记录的数量
				getRecordCount() {
					return this.#record.size;
				}
			}
			
			// 控制面板
			class d_ControlPanel {
				// 调试信息输出
				static debug_mode = false;
				
				// dom元素本体
				#object = null;
				
				// 模拟模式
				#mode = 0;
				
				// 为3.0做准备
				#panel = [];
				
				// 页面视图
				#view_panel = null;
				
				// 章节
				#chapter_id = 0;
				
				// 角色展柜
				#character_container = null;
				
				// 选中角色的顺序下标
				#select_character_index = -1;
				
				// 选中角色的数据
				#select_character_data = ["", "", ""];
				
				// 可编辑区域
				#edit_area = [null, null, null, null, null];
				
				// 图片预览区域
				#preview_area = [null, null];
				
				// 面板拖拽信息
				#drag_data = null;
				
				// 自动保存
				#auto_save_thread = null;
				
				constructor(_object) {
					this.#object = _object;
					this.#view_panel = new d_ViewPanel(document.getElementById("container_content").children[0]);
					scene_panel = new d_ScenePanel(document.getElementById("scene_container"));
					this.#character_container = new d_RadioPanel(document.getElementById("char_case"));
					this.#edit_area = [
						document.getElementById("data_item_type_input"),
						document.getElementById("data_char_path_input"),
						document.getElementById("data_char_name_input"),
						document.getElementsByName("data_talk_input_1"),
						document.getElementsByName("data_talk_input_2"),
						document.getElementsByName("data_talk_input_3"),
						document.getElementsByName("data_talk_input_4"),
						document.getElementsByName("data_talk_input_5"),
						document.getElementsByName("data_talk_input_6")
					];
					this.#edit_area[0] = new d_RadioPanel(this.#edit_area[0]);
					this.#edit_area[0].relateToRear(true);
					this.#edit_area[0].selectItem(0);
					this.#preview_area = [
						this.#edit_area[1].nextElementSibling,
						document.getElementsByName("data_talk_preview_1"),
						document.getElementsByName("data_talk_preview_2"),
						document.getElementsByName("data_talk_preview_3")
					];
					let drag_bean = this.#object.children[0];
					let panel = this;
					drag_bean.ondragstart = function(event) {
						panel.#drag_data = {
							cx: event.clientX,
							cy: event.clientY,
							ix: panel.#object.offsetLeft,
							iy: panel.#object.offsetTop
						};
					};
					drag_bean.ondrag = function(event) {
						panel.dragPanel();
					};
					drag_bean.ondragend = function(event) {
						panel.dragPanel();
					};
					drag_bean.onclick = function(event) {
						panel.resizePanel();
					};
					this.updatePreviewUI();
				}
				
				// 没用，也别用
				loadTemplate(panel_index, id, data) {
					while (this.#panel.firstChild) {
						this.#panel.lastChild.remove();
					}
					let templates = document.getElementById("template");
					if (Array.isArray(id)) {
						for (let i = 0; i < id.length; ++i) {
							let item = templates.children[id[i]].cloneNode();
							setTemplateData(item, data[i]);
							this.#panel[panel_index].appendChild(item);
						}
					}
					else {
						let item = templates.children[id].cloneNode();
						setTemplateData(item, data);
						this.#panel[panel_index].appendChild(item);
					}
				}
				
				// 加载数据，先全部清空再加载
				loadData(chapter) {
					if (chapter == null) {
						chapter = database.getAllRecord("chapter")[0][0];
					}
					if (database.getTag() == "play") {
						this.setSimulateMode(3);
						document.getElementById("scene_ui").setAttribute("onclick", "scene_panel.autoPlay(0);scene_panel.toNext(0);");
						document.getElementById("container").remove();
						document.getElementById("picture_preview").remove();
						document.getElementById("template").remove();
						scene_panel.enable();
						this.#object.remove();
						return null;
					}
					if (database.getRecord("chapter", chapter, 0) == null) {
						console.log("error");
						return null;
					}
					// if (this.#chapter_id == chapter) {
					// 	return;
					// }
					this.#chapter_id = chapter;
					this.clear();
					this.listAllChapter();
					this.listAllCharacter();
					this.#view_panel.listAll(chapter);
				}
				
				exportAsGame() {
					let panel = document.getElementById("control_container");
					panel.innerHTML = "";
					let div = document.createElement("div");
					div.setAttribute("id", "render_output");
					panel.appendChild(div);
					new d_ScenePacker().start();
				}
				
				// 设置模拟模式
				setSimulateMode(type) {
					this.#mode = type;
					let container = document.getElementById("container");
					let scene_container = document.getElementById("scene_container");
					let container_content = document.getElementById("container_content");
					if (type == 0) {
						scene_container.setAttribute("class", "hidden");
						container.removeAttribute("type");
						container_content.removeAttribute("class");
					}
					else if (type == 1) {
						scene_container.setAttribute("class", "hidden");
						container_content.setAttribute("class", "scroll_container");
						container.setAttribute("type", "limited");
					}
					else if (type == 2) {
						container_content.setAttribute("class", "scroll_container");
						container.setAttribute("type", "limited");
						scene_container.removeAttribute("class");
					}
					else if (type == 3) {
						container.setAttribute("class", "hidden");
						scene_container.removeAttribute("class");
					}
				}
				
				// 增加一条消息
				addItem() {
					this.#view_panel.addItem(null, true);
				}
				
				// 移除一条消息
				removeItem() {
					this.#view_panel.removeItem(true);
				}
				
				// 选中一条消息
				selectItem(that) {
					
					let data = this.#view_panel.selectItem(that);
					let box = document.getElementById("char_case");
					let char_id = this.#view_panel.getCharacterData()[0];
					
					// 向场景传递参数
					if (data != null) {
						scene_panel.setName(data[2]);
						scene_panel.setContent(data[3]);
					}
					
					// 向渲染器传递参数
					setSelectItemIndex(this.#view_panel.getSelectItemIndex());
					
					// 更新UI：角色展柜自动选中消息发送人
					let item = null;
					for (let i = 0; i < box.childElementCount; ++i) {
						let id = box.children[i].getAttribute("database-id");
						if (char_id != id) {
							continue;
						}
						item = box.children[i];
						break;
					}
					
					// 更新UI：可编辑区域与消息数据进行同步
					// 如果点击的是空白区域就不更新
					if (data != null) {
						this.selectCharacter(item, false)
						for (let i = 0; i < data.length; ++i) {
							this.setUIData(i, data[i]);
						}
					}
					
					// 更新UI：可编辑区域与消息数据进行同步
					this.updateTip();
					this.updatePreviewUI();
				}
				
				// 获取选中消息的顺序下标
				getSelectItemIndex() {
					return this.#view_panel.getSelectItemIndex();
				}
				
				// 清空选择
				clearSelect() {
					this.#view_panel.selectItem(null);
					this.#select_character_index = -1;
					this.#select_character_data[0] = -1;
					this.updateTip();
				}
				
				// 设置消息类型
				setItemType(that, type) {
					this.#view_panel.setItemType(type, true);
					this.setUIData(0, type);
				}
				
				// 没用
				getItemData(data) {
					
				}
				
				// 设置消息数据
				setItemData(index, data) {
					// console.log( data);
					if (typeof data == 'string') {
						
					}
					else if (data == false) {
						data = '0';
					}
					else if (data == true) {
						data = '1';
					}
					// console.log( data);
					this.#view_panel.setItemData(index, data, true);
					let _data = this.#view_panel.getSelectItemData(false);
					for (let i = 0; i < _data.length; ++i) {
						this.setUIData(i, _data[i]);
					}
					this.updatePreviewUI();
				}
				
				// 移动消息位置
				changeItemIndex(offset) {
					this.#view_panel.changeItemIndex(offset, true);
				}
				
				// 新增一个章节
				// 使用该函数必定向数据库添加空章节
				addChapter(form) {
					let name = form.getElementsByTagName("input")[0].value.trim();
					if (name == "") {
						name = "未命名";
					}
					let id = database.addRecord("chapter", [name, ""]);
					this.listAllChapter();
				}
				
				// 加载一个章节
				loadChapter(form, target_form) {
					let id = form.getElementsByTagName("input")[0].value.trim();
					this.loadData(id);
					let data = database.select("chapter", "*", "id=" + this.#chapter_id);
					if (data == null) {
						return;
					}
					// document.getElementsByName()
					// console.log(data);
					let inputs = target_form.getElementsByTagName("input");
					inputs[0].value = data[0][1];
					for (let i = 1; i < inputs.length; ++i) {
						inputs[i].checked = false;
					}
					if (data[0][2] == "begin") {
						inputs[1].checked = true;
					}
					else if (data[0][2] == "hide") {
						inputs[2].checked = true;
					}
					
				}
				
				// 编辑章节
				editChapter(form) {
					let inputs = form.getElementsByTagName("input");
					let name = inputs[0].value.trim();
					if (name == "") {
						name = "未命名";
					}
					let select = "";
					if (inputs[1].checked) {
						select = "begin";
						inputs[2].checked = false;
						database.update("chapter", "type=", "type=begin");
					}
					else if (inputs[2].checked) {
						select = "hide";
					}
					let id = database.update("chapter", "name=" + d_Tool.escapeString(name, ",") + ",type=" + select, "id=" + this.#chapter_id);
					this.listAllChapter();
				}
				
				// 删除一个章节
				// 不允许删除所有的章节
				deleteChapter(form) {
					let text = form.getElementsByTagName("input")[0].value.trim();
					if (text != "delete") {
						return;
					}
					if (database.getRecordCount("chapter") <= 1) {
						return;
					}
					for (let i = 0; i < form.childElementCount; ++i) {
						if (form.children[i].name == "form_text") {
							form.children[i].value = "";
							break;
						}
					}
					let talk_id = database.select("chapter_talk", "id_t", "id_c=" + this.#chapter_id);
					database.removeRecord("chapter", this.#chapter_id, 0);
					for (let i = 0; i < talk_id.length; ++i) {
						database.removeRecord("chapter_talk", talk_id[i][0], 2);
						database.removeRecord("talk", talk_id[i][0], 0);
						database.removeRecord("talk_character", talk_id[i][0], 1);
					}
					this.loadData();
				}
				
				randomAdvancedParam(form) {
					let data = ["namespace", "author_name", "chinese"];
					let random = Math.floor(Math.random() * data.length);
					let inputs = form.getElementsByTagName("input");
					inputs[0].value = data[random];
					
					data = ["十万个为什么", "百万个为什么", "千万个为什么"];
					random = Math.floor(Math.random() * data.length);
					inputs[1].value = data[random];
					
					data = [0, 1, 2];
					random = Math.floor(Math.random() * data.length);
					inputs[2].value = data[random];
					
					data = ["作者", "author", "你的名字。"];
					random = Math.floor(Math.random() * data.length);
					inputs[3].value = data[random];
					
					data = ["1,逗号\\\\\\,演示,1;1,分号\\;演示,1;1,其他符号~`!@#$%^&*-_=+{[()]}:\'&quot|./?演示,1.2;1,结局1,,1,结局2,"];
					random = Math.floor(Math.random() * data.length);
					form.getElementsByTagName("textarea")[0].value = data[random];
					
					data = ["地铁老人手机.jpg"];
					random = Math.floor(Math.random() * data.length);
					inputs[4].value = data[random];
				}
				
				setAdvancedParam(form) {
					let inputs = form.getElementsByTagName("input");
					this.#setAdvancedParamHelper("namespace", inputs[0].value);
					this.#setAdvancedParamHelper("project_name", inputs[1].value);
					this.#setAdvancedParamHelper("project_version", inputs[2].value);
					this.#setAdvancedParamHelper("author", inputs[3].value);
					this.#setAdvancedParamHelper("chapter_view", form.getElementsByTagName("textarea")[0].value);
					this.#setAdvancedParamHelper("chapter_view_resource", inputs[4].value);
				}
				
				#setAdvancedParamHelper(name, data) {
					let test = database.select("advanced_param", "*", "name=" + name);
					if (test.length == 0) {
						database.addRecord("advanced_param", [name, d_Tool.escapeString(data, ',')]);
					}
					else {
						database.update("advanced_param", "data=" + d_Tool.escapeString(data, ','), "name=" + name);
					}
				}
				
				loadAdvancedParam(form) {
					let inputs = form.getElementsByTagName("input");
					inputs[0].value = this.#loadAdvancedParamHelper("namespace");
					inputs[1].value = this.#loadAdvancedParamHelper("project_name");
					inputs[2].value = this.#loadAdvancedParamHelper("project_version");
					inputs[3].value = this.#loadAdvancedParamHelper("author");
					form.getElementsByTagName("textarea")[0].value = this.#loadAdvancedParamHelper("chapter_view");
					inputs[4].value = this.#loadAdvancedParamHelper("chapter_view_resource");
				}
				
				#loadAdvancedParamHelper(name) {
					let data = database.select("advanced_param", "data", "name=" + name);
					if (data.length != 0) {
						data = data[0][0];
					}
					else {
						data = "";
					}
					return data;
				}
				
				// 展示所有的章节
				listAllChapter() {
					let box = document.getElementById("chapter_case");
					box.innerHTML = "";
					let chapter_data = database.getAllRecord("chapter");
					for (let i = 0; i < chapter_data.length; ++i) {
						let chapter = chapter_data[i];
						let li = document.createElement("li");
						li.innerText = chapter[0] + ": " + chapter[1];
						let selected = false;
						if (this.#chapter_id == chapter[0]) {
							selected = true;
						}
						li.style.borderRadius = "9px";
						if (chapter[2] == "begin") {
							if (selected) {
								li.style.backgroundColor = "#fb2";
								li.style.color = "#fff";
							}
							else {
								li.style.color = "#fb2";
							}
							li.style.fontWeight = "bold";
						}
						else if (chapter[2] == "hide") {
							if (selected) {
								li.style.border = "1px dashed #fb2";
							}
							else {
								li.style.textDecoration = "underline dashed";
							}
							li.style.color = "#999";
						}
						else {
							if (selected) {
								li.style.backgroundColor = "#fb2";
							}
						}
						box.appendChild(li);
					}
				}
				
				// 新增一个角色
				// 如果这是database在读取数据，need_store就是false，表示不需要储存到数据库
				// 如果是用户操作，就需要need_store置为true
				addCharacter(data, need_store) {
					// 有新角色，就把没有角色的提示撤掉
					this.#character_container.getObject().parentNode.children[0].style.display = "none";
					
					// 如果data是null，就使用之前修改的数据
					// 这种情况就是用户新增
					if (data == null) {
						data = this.#select_character_data.slice(0);
					}
					let index = this.#character_container.getCount();
					let img = document.createElement("img");
					img.setAttribute("onclick", "control_panel.selectCharacter(this.parentNode, true)");
					if (data[1] != null) {
						img.src = './img/' + data[1];
					}
					let p = document.createElement("p");
					if (data[2] != null) {
						p.innerText = data[2];
					}
					else {
						p.innerText = "未命名";
					}
					let li = document.createElement("li");
					li.appendChild(img);
					li.appendChild(p);
					
					// 角色展柜新增一个角色
					this.#character_container.addItem(li, index);
					if (need_store) {
						// 主键自增
						let count = database.getPrimaryKeyCount("character") + 1;
						data[0] = count;
						li.setAttribute("database-id", count);
						database.addRecord("character", data);
						this.selectCharacter(li, false);
					}
					else {
						li.setAttribute("database-id", data[0]);
					}
					
				}
				
				// 移除一个角色
				// 标识是否需要数据库同步操作
				removeCharacter(need_store) {
					let index = this.#select_character_index;
					if (index < 0) {
						return;
					}
					this.#character_container.removeItem(index);
					if (need_store) {
						database.removeRecord("character", this.#select_character_data[0]);
						// database.storeData();
						this.#view_panel.updateItemCharacterData(this.#select_character_data[0]);
					}
					this.#select_character_index = -1;
					this.#select_character_data[0] = -1;
					
					// 如果没有角色，就把提示搬出来
					if (this.#character_container.getCount() == 0) {
						this.#character_container.getObject().parentNode.children[0].style.display = null;
					}
				}
				
				// 选择角色
				// 标识是否需要数据库同步操作
				selectCharacter(that, need_store) {
					// 出bug了？
					if (that == null) {
						this.#select_character_index = -1;
						this.#select_character_data[0] = -1;
						this.#character_container.clearSelect();
						return false;
					}
					this.#select_character_index = this.#character_container.getItemIndex(that);
					let id = that.getAttribute("database-id");
					
					// 重复选中同一角色
					if (id == this.#select_character_data[0]) {
						return false;
					}
					
					// 同步数据
					this.#select_character_data[0] = id;
					this.#select_character_data = database.getRecord("character", this.#select_character_data[0], null);
					
					// 更新UI
					this.#character_container.selectItem(this.#select_character_index);
					let data = this.#view_panel.setCharacterData(this.#select_character_data, need_store);
					if (data.length == 0) {
						this.setUIData(1, this.#select_character_data[1]);
						this.setUIData(2, this.#select_character_data[2]);
					}
					else {
						for (let i = 0; i < data.length; ++i) {
							this.setUIData(i, data[i]);
						}
					}
					this.updatePreviewUI();
					return true;
				}
				
				// 设置角色数据
				// 标识是否需要数据库同步操作
				setCharacterData(data, need_store) {
					// console.trace(data);
					let index = this.#select_character_index;
					let item = this.#character_container.getItem(index);
					
					// 更新UI
					if (data[0] != null) {
						this.#select_character_data[1] = data[0];
						if (item != null) {
							item.children[0].src = "./img/" + data[0];
						}
					}
					if (data[1] != null) {
						this.#select_character_data[2] = data[1];
						if (item != null) {
							item.children[1].innerText = data[1];
						}
					}
					this.updatePreviewUI();
					
					// 如果没有选中角色，就说明没在修改现有角色
					if (!this.#character_container.isIndexValid(index)) {
						// console.log(this.#character_container.getObject());
						return;
					}
					if (need_store) {
						database.setRecord("character", this.#select_character_data[0], this.#select_character_data.slice(1));
						// database.storeData();
						this.#view_panel.updateItemCharacterData(this.#select_character_data[0]);
					}
				}
				
				// 将所有角色罗列出来，一般在使用前需要先清空角色展柜
				// 因为读数据操作，不需要保存
				listAllCharacter() {
					let data = database.getAllRecord("character");
					for (let i = 0; i < data.length; ++i) {
						this.addCharacter(data[i], false);
					}
				}
				
				// 获取可编辑区域的数据
				// 没用
				getUIData(index) {
					if (index == 0) {
						return null;
					}
					else {
						return this.#edit_area[index].value;
					}
				}
				
				// 设置可编辑区域的数据，用于同步消息数据
				setUIData(index, data) {
					let parent = this.#edit_area[index];
					if (index == 0) {
						parent.selectItem(data - 1);
					}
					else if (index < 3) {
						parent.value = data;
					}
					else {
						for (let i = 0; i < parent.length; ++i) {
							let type = parent[i].getAttribute("type");
							if (type == "number" && isNaN(data)) {
								continue;
							}
							else if (type == "list") {
								let flag = false;
								for (let j = 0; j < parent[i].options.length; ++j) {
									if (parent[i].options[j].value == data) {
										parent[i].options[j].selected = true;
										flag = true;
										break;
									}
								}
								if (!flag) {
									parent[i].options[0].selected = true;
								}
							}
							else if (type == "checkbox") {
								if (data == "0") {
									parent[i].checked = false;
									parent[i].nextElementSibling.innerText = "否";
								}
								else if (data == "1") {
									parent[i].checked = true;
									parent[i].nextElementSibling.innerText = "是";
								}
								else {
									parent[i].nextElementSibling.innerText = "未选择";
								}
							}
							else {
								parent[i].value = data;
							}
						}
					}
				}
				
				// 更新资源预览
				updatePreviewUI() {
					this.#preview_area[0].src = "./img/" + this.#edit_area[1].value;
					for (let i = 0; i < this.#preview_area[1].length; ++i) {
						this.#preview_area[1][i].src = "./img/" + this.#edit_area[3][0].value;
					}
					for (let i = 0; i < this.#preview_area[3].length; ++i) {
						if (this.#preview_area[3][i].tagName.toLowerCase() == "audio") {
							this.#preview_area[3][i].src = "./aud/" + this.#edit_area[5][1].value;
						}
						else {
							this.#preview_area[3][i].src = "./img/" + this.#edit_area[5][2].value;
						}
					}
				}
				
				// 清空所有数据
				clear() {
					this.autoSave(false);
					this.clearSelect();
					this.#character_container.clear();
					this.#view_panel.clear();
				}
				
				// 更新提示
				updateTip() {
					let str = "";
					let index = this.#view_panel.getSelectItemIndex();
					if (index < 0) {
						str = "未在编辑，";
					}
					else {
						str = "正在编辑第" + (index + 1) + "项，";	
					}
					if (this.#auto_save_thread != null) {
						str += "启用自动保存，"
					}
					str += "上次保存时间：" + database.getLastSaveTime();
					
					let tip = document.getElementById("debug_panel");
					if (tip != null) {
						tip.innerText = str;
					}
				}
				
				// 拖拽面板
				dragPanel() {
					let pos = {
						x: event.clientX - this.#drag_data.cx + this.#drag_data.ix,
						y: event.clientY - this.#drag_data.cy + this.#drag_data.iy
					}
					if (pos.x <= 0 && pos.y <= 0) {
						return;
					}
					if (pos.x < 10) {
						pos.x = 10;
					}
					else if (pos.x > window.innerWidth - this.#object.offsetWidth - 10) {
						pos.x = window.innerWidth - this.#object.offsetWidth - 10;
					}
					if (pos.y < 10) {
						pos.y = 10;
					}
					else if (pos.y > window.innerHeight - this.#object.offsetHeight - 10) {
						pos.y = window.innerHeight - this.#object.offsetHeight - 10;
					}
					
					if (pos.x < 10) {
						pos.x = 10;
					}
					if (pos.y < 10) {
						pos.y = 10;
					}
					this.#object.style.left = pos.x + "px";
					this.#object.style.top = pos.y + "px";
				}
				
				// 变更面板形态
				resizePanel(type) {
					if (type == null) {
						type = this.#object.getAttribute("type");
						++type;
					}
					type %= 3;
					this.#object.setAttribute("type", type);
				}
				
				autoSave(judge) {
					if (judge == true) {
						database.storeData();
						clearInterval(this.#auto_save_thread);
						this.#auto_save_thread = setInterval(function() {
							database.storeData();
						}, 1000 * 180);
					}
					else if (judge == false) {
						clearInterval(this.#auto_save_thread);
						this.#auto_save_thread = null;
						control_panel.updateTip();
					}
					else if (this.#auto_save_thread == null) {
						database.storeData();
						this.#auto_save_thread = setInterval(function() {
							database.storeData();
						}, 1000 * 180);
					}
					else {
						clearInterval(this.#auto_save_thread);
						this.#auto_save_thread = null;
						control_panel.updateTip();
					}
				}
				debugLog(str) {
					console.log("[ControlPanel] " + str);
				}
				debugLogError(str) {
					console.error("[ControlPanel] " + str);
				}
			}
			
			// 页面视图
			class d_ViewPanel {
				// 调试信息输出开关
				static debug_mode = false;
				
				// 控制面板选中的角色的信息
				#select_character_data = [0, null, null];
				
				// 用于存放消息的容器
				#container = null;
				
				// 章节id
				#chapter_id = 0;
				
				// 选中消息的顺序下标，小于0表示没选中
				#select_item_index = -1;
				
				// 选中消息的数据
				// 数据
				#select_item_data = [-1, 1, "", "", "", "", "", ""];
				
				// 选中消息的数据转UI同步数据，用于给控制面板显示
				#select_item_data_ui = [1, 1, "", 0];
				constructor(container) {
					this.#container = new d_RadioPanel(container);
				}
				
				// 新增一条消息
				// 标识是否需要数据库同步操作
				addItem(data, need_store) {
					if (data == null) {
						data = this.#select_item_data.slice(0);
					}
					
					// 如果没选中消息，就在末尾追加消息，否则在选中消息的下方插入
					let index = this.#select_item_index;
					if (!this.#container.isIndexValid(index)) {
						index = this.#container.getCount();
					}
					else {
						++index;
					}
					if (d_ViewPanel.debug_mode && need_store) {
						this.debugLog("第" + index + "项插入:" + data);
					}
					
					// 通过消息类型，从模版中copy一个过来
					let item = this.getTemplate(data[1] - 1);
					if (need_store) {
						// 数据库主键自增
						data[0] = database.getPrimaryKeyCount("talk") + 1;
						// let id = database.getPrimaryKeyCount("talk_character") + 1;
						
						item.setAttribute("database-id", data[0]);
						this.#container.addItem(item, index);
						database.addRecord("talk", data);
						// database.setRecordIndex("talk", data[0], index);
						database.addRecord("talk_character", [data[0], this.#select_character_data[0]]);
						database.addRecord("chapter_talk", [this.#chapter_id, data[0]]);
						// database.storeData();
					}
					else {
						item.setAttribute("database-id", data[0]);
						this.#container.addItem(item, index);
					}
					this.selectItem(item);
					for (let i = 1; i < data.length; ++i) {
						this.setItemData(i - 1, data[i], false);
					}
					this.clearSelect();
				}
				
				// 移除一条消息
				// 标识是否需要数据库同步操作
				removeItem(need_store) {
					let index = this.#select_item_index;
					if (index < 0) {
						return;
					}
					this.#container.removeItem(index);
					if (need_store) {
						let id = this.#select_item_data[0];
						database.removeRecord("talk", id);
						database.removeRecord("talk_character", id);
						let ct_id = database.select("chapter_talk", "id", "id_t=" + id);
						database.removeRecord("chapter_talk", ct_id);
						// database.storeData();
					}
					this.#select_item_index = -1;
					this.#select_item_data[0] = -1;
				}
				
				// 选中一条消息
				selectItem(that) {
					let index = this.#container.getItemIndex(that);
					
					
					// 同一条就取消选中
					if (index < 0 || this.#select_item_index == index) {
						this.clearSelect();
						return null;
					}
					this.#select_item_index = index;
					this.#select_item_data[0] = that.getAttribute("database-id");
					this.#select_item_data = database.getRecord("talk", this.#select_item_data[0], 0);
					
					let d_data = database.getRecord("talk_character", this.#select_item_data[0], 1);
					if (d_data != null) {
						this.#select_character_data[0] = d_data[2];
						d_data = database.getRecord("character", d_data[2], 0);
					}
					// 不能用else
					if (d_data == null) {
						d_data = [null, null, null];
					}
					this.#select_character_data[1] = d_data[1];
					this.#select_character_data[2] = d_data[2];
					
					// 将消息的数据转化为显示在控制面板UI上的信息
					this.#select_item_data_ui = [
						this.#select_item_data[1],
						this.#select_character_data[1],
						this.#select_character_data[2],
						this.#select_item_data[2],
						this.#select_item_data[3],
						this.#select_item_data[4],
						this.#select_item_data[5],
						this.#select_item_data[6],
						this.#select_item_data[7]
					];
					this.#container.selectItem(this.#select_item_index);
					return this.#select_item_data_ui;
				}
				
				// 取消选中
				clearSelect() {
					this.#container.clearSelect();
					this.#select_item_index = -1;
					this.#select_item_data[0] = -1;
				}
				
				// 设置消息类型
				// 标识是否需要数据库同步操作
				setItemType(type, need_store) {
					let cur_type = this.#select_item_data[1];
					if (type == cur_type) {
						return;
					}
					this.#select_item_data[1] = type;
					this.#select_item_data_ui[0] = type;
					let index = this.#select_item_index;
					if (!this.#container.isIndexValid(index)) {
						return;
					}
					
					// 把以前的删掉，放一个新的进来
					this.#container.removeItem(index);
					let item = this.getTemplate(type - 1);
					item.setAttribute("database-id", this.#select_item_data[0]);
					this.#container.addItem(item, index);
					let data = this.#select_item_data.slice(1);
					this.setItemData(0, type, false);
					this.#container.selectItem(index);
					if (need_store) {
						database.setRecord("talk", this.#select_item_data[0], data);
						// database.storeData();
					}
				}
				
				// 设置消息数据，接受不含key（数据库主键）的数据
				// 标识是否需要数据库同步操作
				setItemData(index, data, need_store) {
					if (data != null) {
						this.#select_item_data[index + 1] = data;
					}
					// else {
					// 	return;
					// }
					this.#select_item_data_ui = [
						this.#select_item_data[1],
						this.#select_character_data[1],
						this.#select_character_data[2],
						this.#select_item_data[2],
						this.#select_item_data[3],
						this.#select_item_data[4],
						this.#select_item_data[5],
						this.#select_item_data[6],
						this.#select_item_data[7]
					];
					index = this.#select_item_index;
					if (!this.#container.isIndexValid(index)) {
						return;
					}
					let t_data = [
						this.#select_character_data[1],
						this.#select_character_data[2],
						this.#select_item_data[2],
						this.#select_item_data[3],
						this.#select_item_data[4],
						this.#select_item_data[5],
						this.#select_item_data[6],
						this.#select_item_data[7]
					];
					let item = this.#container.getItem(index);
					// let main_type = item.getAttribute("main-type");
					// if (main_type == "talk") {
						
					// 更新UI
					let div = null;
					div = item.getElementsByClassName("talk_icon")[0];
					if (div != null && t_data[0] != null) {
						div.src = './img/' + t_data[0];
					}
					
					div = item.getElementsByClassName("talk_name")[0];
					if (div != null) {
						div.innerText = t_data[1];
					}
					
					let type = parseInt(item.getAttribute("type"));
					t_data = this.#getComponentData(t_data, type);
					div = item.getElementsByClassName("talk_container")[0];
					for (let loop = 0; loop < div.childElementCount; ++loop) {
						for (let i = 0; i < div.children[loop].childElementCount; ++i) {
							this.#setComponentData(t_data, div.children[loop].children[i]);
						}
					}
					
					// }
					if (need_store) {
						database.setRecord("talk", this.#select_item_data[0], this.#select_item_data.slice(1));
						// database.storeData();
					}
				}
				
				// 通过消息类型type和消息数据data获得一份定制的数据
				#getComponentData(data, type) {
					let res = data.slice(2);
					if (type <= d_DataEnum.MID_IMAGE) {
						
					}
					else if (type <= d_DataEnum.MID_AUDIO) {
						let temp = parseInt(res[1]);
						if (isNaN(temp)) {
							temp = 1;
						}
						if (temp < 1) {
							temp = 1;
						}
						else if (temp > 60) {
							temp = 60;
						}
						// let minute = parseInt(temp / 60);
						// let second = temp % 60;
						let str = "";
						// if (minute != 0 && minute != 1) {
						// 	str += minute + "'";
						// }
						// if (second != 0) {
							str += temp + "\"";
						// }
						// else if (minute == 1) {
						// 	str = "60\"";
						// }
						res[1] = str;
					}
					return res;
				}
				
				// 通过定制的数据data，修改消息item的UI数据
				#setComponentData(data, item) {
					let clone_data = data.slice(0);
					let type = item.getAttribute("content-type");
					if (type == "text") {
						item.innerText = clone_data[0];
					}
					else if (type == "image") {
						if (clone_data[0] != null && clone_data[0].trim().length != 0) {
							item.src = "./img/" + clone_data[0];
						}
						else {
							item.src = null;
						}
						if (clone_data[1] < 50) {
							item.style.width = null;
						}
						else {
							item.style.width = clone_data[1] + "px";
						}
					}
					else if (type == "audio") {
						let time = parseInt(clone_data[1]);
						let count = Math.round(8 + (40 - 8) * time / 60);
						for (let i = item.childElementCount; i < count; ++i) {
							item.appendChild(document.createElement("div"));
						}
						while (item.childElementCount > count) {
							item.removeChild(item.lastChild);
						}
					}
					else if (type == "audio_duration") {
						item.innerText = clone_data[1];
					}
					else if (type == "audio_translate") {
						if (clone_data[0] == null || clone_data[0].trim().length == 0) {
							item.parentNode.style.display = "none";
						}
						else {
							item.parentNode.removeAttribute("style");
							item.innerText = clone_data[0];
						}
					}
				}
				
				// 获取选中消息的顺序下标
				getSelectItemIndex() {
					return this.#select_item_index;
				}
				
				// 改变消息的顺序位置
				// 肯定需要数据库同步操作
				changeItemIndex(offset) {
					let index = this.#select_item_index;
					if (index < 0) {
						return;
					}
					if (offset > 0) {
						offset = 1;
					}
					else {
						offset = -1;
					}
					let target = this.#container.getItem(index + offset);
					let new_index = this.#container.setItemIndex(index, index + offset);
					if (new_index == -1) {
						return;
					}
					target = target.getAttribute("database-id");
					this.#select_item_index = new_index;
					// database.setRecordIndex("talk", this.#select_item_data[0], new_index);
					let ct_id = database.getRecord("chapter_talk", this.#select_item_data[0], 2);
					if (ct_id != null) {
						database.swapRecordIndex("chapter_talk", ct_id[0], target);
						// database.storeData();
					}
				}
				
				// 获取选中消息的数据
				getSelectItemData(origin) {
					if (!this.#container.isIndexValid(this.#select_item_index)) {
						return [];
					}
					if (origin) {
						return this.#select_item_data.slice(0);
					}
					return this.#select_item_data_ui.slice(0);
				}
				
				// 更新所有消息的角色数据
				// 比如用户改了角色名、删除了角色，都需要更新视图中该角色对应消息的UI
				updateItemCharacterData(char_id) {
					// let data = database.getRecord("talk_character", char_id, 2);
					let data = database.select("talk_character", "id_t", "id_c=" + char_id);
					if (data.length == 0) {
						return;
					}
					// data = [data[1], data[2]];
					// console.log(data);
					
					// 获取所有受影响的消息的id
					let _set = new Set();
					for (let i = 0; i < data.length; ++i) {
						_set.add(data[i][0]);
					}
					// _set.delete(char_id.toString());
					
					// 获取最新的角色信息
					data = database.getRecord("character", char_id, 0);
					if (data == null) {
						data = [null, null, null];
					}
					
					// 将最新消息应用到所有受影响的消息UI上
					for (let i = 0; i < this.#container.getCount(); ++i) {
						let item = this.#container.getItem(i);
						let id = item.getAttribute("database-id");
						// id = parseInt(id);
						if (_set.has(id)) {
							_set.delete(id);
							let div = null;
							div = item.getElementsByClassName("talk_icon")[0];
							if (div != null) {
								if (data[1] != null) {
									div.src = './img/' + data[1];
								}
								else {
									div.src = "";
								}
							}
							div = item.getElementsByClassName("talk_name")[0];
							if (div != null) {
								div.innerText = data[2];
							}
						}
					}
				}
				
				// 设置角色数据，用于改变消息发送人
				// 标识是否需要数据库同步操作
				setCharacterData(data, need_store) {
					for (let i = 0; i < data.length; ++i) {
						if (data[i] != null) {
							this.#select_character_data[i] = data[i];
						}
					}
					let index = this.#select_item_index;
					if (index < 0) {
						return [];
					}
					if (need_store) {
						database.setRecord("talk_character", this.#select_item_data[0], [this.#select_item_data[0], this.#select_character_data[0]]);
						// database.storeData();
					}
					this.setItemData(0, null, false);
					return this.#select_item_data_ui;
				}
				
				// 获取选中消息的角色的数据
				getCharacterData() {
					return this.#select_character_data;
				}
				
				// 列出所有的消息
				listAll(chapter) {
					this.#chapter_id = chapter;
					let talk_id = database.select("chapter_talk", "id_t", "id_c=" + chapter);
					this.clear();
					for (let i = 0; i < talk_id.length; ++i) {
						let data = database.getRecord("talk", talk_id[i][0], 0);
						this.addItem(data, false);
					}
				}
				
				// 清空数据
				clear() {
					this.clearSelect();
					this.#container.clear();
				}
				
				// 通过消息类型获取模版dom元素
				getTemplate(index) {
					return document.getElementById("template").children[index].cloneNode(true);
				}
				debugLog(str) {
					console.log("[ViewPanel] " + str);
				}
				debugLogError(str) {
					console.error("[ViewPanel] " + str);
				}
			}
			
			// 场景视图
			class d_ScenePanel {
				
				static version = "3";
				
				// dom元素本体
				#container = null;
				
				// 元素组件
				#components = {
					cover: null,
					background: null,
					sound: null,
					talk_content: null,
					talk_name: null,
					option: null,
					chapter_view: null,
					chapter_view_scroll: null,
					chapter_view_content: null,
					history: null,
					history_scoll: null,
					history_content: null,
					pop_note: null
				};
				
				// 场景是否启用
				#enable = false;
				
				// 当前正在浏览的对话序号
				#index = -1;
				
				// 玩家点击，文字生成，图片生成，选择选项
				#finish = [false, true, true, true];
				
				// 场景保存的信息，数据来源于数据库talk表
				#data_id = null;
				#data = [null, null, null, null, null, null];
				
				// 逐个显示对话文字的线程
				#text_thread = null;
				// 显示到第几个字
				#textIndex = 0;
				
				// 图片控制器
				#image_control = new Map();
				// 渐变显示图片的线程
				#image_thread = null;
				#image_keys = [];
				
				// 音频控制器
				#audio_control = new Map();
				#audio_keys = [];
				// 渐变播放音频的线程
				#audio_thread = null;
				
				// 变量键值对
				#param_map = new Map();
				
				// 选项跳转章节序号
				#option_target = null;
				
				#pop_note_param = {
					thread: null,
				}
				
				#chapter_view_param = {
					// 是否章节视图更新后未被打开过
					update: false,
					// 一个map，用于记录章节序号对应章节节点的子对象下标
					// 记录已解锁章节
					unlock_id_map: null,
					// 记录未解锁章节
					locked_id_map: null,
					// 记录隐藏章节
					hidden_id_map: null,
					// 记录错误章节
					error_id_map: null
				}
				
				#history_param = {
					// 是否更新后未被打开过
					update: false
				}
				
				#auto_play_param = {
					thread: null,
					// 是否处于工作过程中
					working: false,
					type: 0,
					click_time: "none",
					click_delay: 100,
					click_delay_factor: 100,
					timer: -1,
					
					// 接收来自其他线程的信息
					text_played: false,
					text_length: 0,
					
					audio_playing_depth: -1
				}
				
				#scene_tools = {
					skip: null,
					auto_play: null,
					history: null,
					progress: null
				}
				
				// 该作品的信息
				#work_info = {
					_namespace: "",
					name: "",
					version: 0,
					author: "",
				}
				
				constructor(container) {
					this.#container = container;
					this.#components.cover = document.getElementById("scene_cover");
					this.#components.background = document.getElementById("scene_background");
					this.#components.talk_name = container.getElementsByClassName("talk_name")[0];
					this.#components.talk_content = container.getElementsByClassName("talk_container")[0];
					this.#components.sound = document.getElementById("scene_sound");
					this.#components.option = document.getElementById("scene_option");
					this.#components.chapter_view = document.getElementById("scene_chapter_view");
					this.#components.chapter_view_content = this.#components.chapter_view.children[0].children[0];
					this.#components.history = document.getElementById("scene_history");
					this.#components.history_content = this.#components.history.children[0].children[0].children[0];
					this.#components.pop_note = document.getElementById("scene_pop_note");
					
					let temp = document.getElementById("scene_tool");
					this.#scene_tools.progress = temp.children[1];
					this.#scene_tools.history = temp.children[2];
					this.#scene_tools.auto_play = temp.children[3];
					this.#scene_tools.skip = temp.children[4];
				}
				
				setContent(text) {
					if (!this.#enable) {
						return;
					}
					this.#data[3] = text;
					this.#components.talk_content.innerText = this.#data[3];
				}
				
				setName(text) {
					if (!this.#enable) {
						return;
					}
					this.#data[2] = text;
					this.#components.talk_name.innerText = this.#data[2];
				}
				
				async enable() {
					this.clearAll();
					// let code = await this.loadData();
					// if (code != null) {
					// 	alert(code);
					// 	return;
					// }
					this.#enable = true;
					this.fetchWorkData();
					this.showCover(false);
					// this.loadData();
				}
				
				async newBeginning() {
					this.clearAll();
					let self = this;
					await this.loadData();
					let code = this.loadChapter();
					if (code != null) {
						alert(code);
						return;
					}
					self.hideCover();
					self.toNext(0);
				}
				
				fetchWorkData() {
					let data = database.select("advanced_param", "data", "name=namespace");
					if (data.length == 0) {
						data = "";
					}
					else {
						data = data[0][0];
					}
					this.#work_info._namespace = data;
					
					data = database.select("advanced_param", "data", "name=project_name");
					if (data.length == 0) {
						data = "";
					}
					else {
						data = data[0][0];
					}
					this.#work_info.name = data;
					this.#components.cover.children[0].children[1].innerText = data;
					
					data = database.select("advanced_param", "data", "name=project_version");
					if (data.length == 0) {
						data = 0;
					}
					else {
						data = parseInt(data[0][0]);
						if (isNaN(data)) {
							data = 0;
						}
					}
					this.#work_info.version = data;
					
					data = database.select("advanced_param", "data", "name=author");
					if (data.length == 0) {
						data = "";
					}
					else {
						data = data[0][0];
					}
					this.#work_info.author = data;
					this.#components.cover.children[0].children[2].innerText = data;
				}
				
				clearAll() {
					// console.trace("clear all");
					this.#chapter_view_param.unlock_id_map = new Map();
					this.#chapter_view_param.locked_id_map = new Map();
					this.#chapter_view_param.hidden_id_map = new Map();
					this.#param_map = new Map();
					this.#components.chapter_view.children[1].removeAttribute("hidden");
					this.#components.history.children[1].removeAttribute("hidden");
					clearTimeout(this.#pop_note_param.thread);
					this.#pop_note_param.thread = null;
					this.#components.chapter_view_content.innerHTML = null;
					this.clearContent();
				}
				
				clearContent() {
					clearInterval(this.#image_thread);
					this.#image_thread = null;
					clearInterval(this.#audio_thread);
					this.#audio_thread = null;
					clearInterval(this.#text_thread);
					this.#text_thread = null;
					this.#image_control = new Map();
					this.#image_keys = [];
					this.#audio_control = new Map();
					this.#audio_keys = [];
					this.#index = -1;
					this.#textIndex = 0;
					this.#components.background.innerHTML = "";
					this.#components.talk_name.innerHTML = "";
					this.#components.talk_content.innerHTML = "";
					this.#components.sound.innerHTML = "";
					this.#components.option.innerHTML = "";
					this.#components.option.setAttribute("style", "display:none;");
					for (let i = 0; i < this.#finish.length; ++i) {
						this.#finish[i] = true;
					}
					this.#clearHistory();
					this.autoPlay(0);
				}
				
				storeProgress() {
					if (this.#data[0] == null) {
						return;
					}
					// console.log("开始记录数据");
					let data = "";
					let count = 0;
					let t_data = "";
					// let record_id = new Set();
					
					data += "scene_data," + d_Tool.escapeString(this.#work_info._namespace, ",") + ",";
					data += d_Tool.escapeString(this.#work_info.name, ",") + ",";
					data += d_Tool.escapeString(this.#work_info.version, ",") + ",";
					data += d_Tool.escapeString(this.#work_info.author, ",") + ",";
					
					// 记录当前对话的所用图片
					// console.log("image");
					// console.log(this.#image_control);
					for (let i = 0; i < this.#image_keys.length; ++i) {
						let struct = this.#image_control.get(this.#image_keys[i]);
						if (struct.progress) {
							++count;
							t_data += struct.talk_id + ",";
							// console.log(struct);
							// record_id.add(struct.talk_id);
						}
					}
					data += count + "," + t_data;
					
					// 记录当前对话的所用音乐
					// console.log("audio");
					// console.log(this.#image_control);
					count = 0;
					t_data = "";
					for (let i = 0; i < this.#audio_keys.length; ++i) {
						let struct = this.#audio_control.get(this.#audio_keys[i]);
						if (struct.progress && struct.background) {
							++count;
							t_data += struct.talk_id + ",";
							// console.log(struct);
							// record_id.add(struct.talk_id);
						}
					}
					data += count + "," + t_data;
					
					// 记录当前对话的id
					// console.log("current:" + this.#data[0]);
					data += this.#data[0] + ",";
					
					// 记录自定义变量
					// console.log("param");
					count = 0;
					t_data = "";
					let keys = Array.from(this.#param_map.keys());
					for (let i = 0; i < keys.length; ++i) {
						t_data += keys[i] + "," + this.#param_map.get(keys[i]) + ",";
						// console.log(keys[i] + "=" + this.#param_map.get(keys[i]));
					}
					data += keys.length + "," + t_data;
					
					// 记录已解锁章节
					// console.log("chapter");
					count = 0;
					t_data = "";
					keys = Array.from(this.#chapter_view_param.unlock_id_map.keys());
					for (let i = 0; i < keys.length; ++i) {
						t_data += keys[i] + ",";
						// console.log(keys[i] + ",");
					}
					data += keys.length + "," + t_data;
					
					data += this.#data[0];
					localStorage.setItem("el_play", data);
				}
				
				loadProgress(str) {
					if (str == null) {
						str = localStorage.getItem("el_play");
						if (str == null || str.length == 0) {
							return null;
						}
						str = this.loadProgress(str);
						if (str != null) {
							localStorage.removeItem("el_play");
							alert(str);
							this.clearAll();
							this.showCover();
						}
						return null;
					}
					this.clearAll();
					this.hideCover();
					let self = this;
					this.loadData(function() {
						let code = self.parseProgressString(str);
						if (code != null) {
							alert(code);
							self.clearAll();
							self.showCover(false);
						}
					});
				}
				
				parseProgressString(str) {
					let data = d_Tool.splitString(str, ',');
					let index = 0;
					// console.log(data);
					
					// 读取首部
					if (data.length < 5) {
						return "存档首部错误，这可能不是一个存档文件:" + index;
					}
					if (data[index] != "scene_data") {
						return "未匹配的存档数据:" + index;
					}
					++index;
					if (data[index] != this.#work_info._namespace) {
						return "未匹配的存档数据:" + index;
					}
					++index;
					if (data[index] != this.#work_info.name) {
						return "未匹配的存档数据:" + index;
					}
					++index;
					if (true) {
						let num = parseInt(data[index]);
						if (isNaN(num)) {
							num = 0;
						}
						if (num > this.#work_info.version) {
							return "存档版本高于作品版本:" + index;
						}
					}
					++index;
					if (data[index] != this.#work_info.author) {
						return "未匹配的存档数据:" + index;
					}
					++index;
					
					// 读取图片
					if (index >= data.length) {
						return "存档数据错误1:" + index;
					}
					let len = data[index];
					len = parseInt(len);
					if (isNaN(len)) {
						return "存档数据错误1:" + index;
					}
					if (index + len >= data.length) {
						return "存档数据错误1:" + index;
					}
					++index;
					for (let i = 0; i < len; ++i) {
						let id = parseInt(data[index]);
						if (isNaN(id)) {
							return "存档数据错误1:" + index;
						}
						let temp = database.select("talk", "*", "id=" + id);
						if (temp.length == 0) {
							return "存档数据错误1:" + index;
						}
						this.decodeData(temp[0]);
						++index;
					}
					
					// 读取音频
					if (index >= data.length) {
						return "存档数据错误2:" + index;
					}
					len = data[index];
					len = parseInt(len);
					if (isNaN(len)) {
						return "存档数据错误2:" + index;
					}
					if (index + len >= data.length) {
						return "存档数据错误2:" + index;
					}
					++index;
					for (let i = 0; i < len; ++i) {
						let id = parseInt(data[index]);
						if (isNaN(id)) {
							return "存档数据错误2:" + index;
						}
						let temp = database.select("talk", "*", "id=" + id);
						if (temp.length == 0) {
							return "存档数据错误2:" + index;
						}
						this.decodeData(temp[0]);
						++index;
					}
					
					// 加载当前对话
					if (index >= data.length) {
						return "存档数据错误3.1:" + index;
					}
					len = data[index];
					len = parseInt(len);
					if (isNaN(len)) {
						return "存档数据错误3.2:" + index;
					}
					if (len > 0) {
						let temp = database.select("talk", "*", "id=" + len);
						if (temp.length == 0) {
							return "存档数据错误3.3:" + index;
						}
						let chapter = database.select("chapter_talk", "id_c", "id_t=" + len);
						if (chapter.length == 0) {
							return "存档数据错误3.4:" + index;
						}
						this.#data_id = database.select("chapter_talk", "id", "id_c=" + chapter[0][0]);
						for (let i = 0; i < this.#data_id.length; ++i) {
							if (this.#data_id[i][0] == len) {
								this.#index = i - 1;
								break;
							}
						}
						// console.log(len)
						this.#data = temp[0];
						// console.log(this.#data);
						// this.decodeData(data[0]);
					}
					++index;
					
					// 读取变量
					if (index >= data.length) {
						return "存档数据错误4:" + index;
					}
					len = data[index];
					len = parseInt(len);
					if (isNaN(len)) {
						return "存档数据错误4:" + index;
					}
					if (index + len >= data.length) {
						return "存档数据错误4:" + index;
					}
					++index;
					for (let i = 0; i < len; ++i) {
						let name = data[index];
						++index;
						let id = parseInt(data[index]);
						++index;
						if (isNaN(id)) {
							return "存档数据错误4:" + index;
						}
						this.#param_map.set(name, id);
					}
					
					// 读取已解锁章节
					if (index >= data.length) {
						return;
					}
					len = data[index];
					len = parseInt(len);
					if (isNaN(len)) {
						return "存档数据错误5:" + index;
					}
					if (index + len >= data.length) {
						return "存档数据错误5:" + index;
					}
					++index;
					for (let i = 0; i < len; ++i) {
						let id = parseInt(data[index]);
						if (isNaN(id)) {
							return "存档数据错误5:" + index;
						}
						this.unlockChapter(id);
						++index;
					}
					this.toNext(0);
					// console.log("已载入数据");
					return null;
				}
				
				loadProgressFile(that) {
					if (that.files.length == 0) {
						return;
					}
					let reader = new FileReader();
					let self = this;
					reader.readAsArrayBuffer(that.files[0]);
					reader.onload = function() {
						let br = new d_BinaryReader(new DataView(reader.result));
						self.loadProgress(br.getString());
					};
				}
				
				unlockChapter(id) {
					if (this.#chapter_view_param.locked_id_map.has(id)) {
						let value = this.#chapter_view_param.locked_id_map.get(id);
						this.#chapter_view_param.unlock_id_map.set(id, value);
						this.#chapter_view_param.locked_id_map.delete(id);
						this.#repaintChapterRelationView();
						// this.#clearHistory();
						this.popInfo("章节已解锁", "您的存档已更新。", 1000);
					}
				}
				
				async loadData(callback) {
					await this.loadChapterView();
					if (callback != null) {
						callback();
					}
				}
				
				loadChapter(chapter_id) {
					let key = chapter_id;
					let error = null;
					if (chapter_id == null) {
						key = database.select("chapter", "id", "type=begin");
						if (key.length == 0) {
							error = "未发现起始章节";
							return error;
						}
						key = key[0][0];
					}
					
					// 解锁该章节
					this.unlockChapter(key);
					
					// 判断有无内容
					key = database.select("chapter_talk", "id_t", "id_c=" + key);
					if (key.length == 0) {
						error = "章节内容为空";
						return error;
					}
					this.#data_id = key;
					this.#index = -1;
					let tk_id = this.#data_id[0][0];
					this.#data = database.getRecord("talk", tk_id, 0);
					this.storeProgress();
					// this.toNext(0);
					
					return error;
				}
				
				showCover(can_close) {
					if (can_close) {
						this.#components.cover.children[0].lastElementChild.removeAttribute("hidden");
					}
					else {
						this.#components.cover.children[0].lastElementChild.setAttribute("hidden", true);
						this.clearContent();
					}
					this.#components.cover.removeAttribute("hidden");
				}
				
				hideCover() {
					this.#components.cover.setAttribute("hidden", true);
				}
				
				toNext(id) {
					this.#finish[id] = true;
					// let flag = true;
					// console.error(this.#finish);
					// console.log(this.#data);
					let type = this.#data[1];
					for (let i = 0; i < this.#finish.length; ++i) {
						if (type > d_DataEnum.MID_TEXT && type <= d_DataEnum.MID_IMAGE) {
							if (this.#finish[2]) {
								break;
							}
							return;
						}
						else if (type == d_DataEnum.OPTION) {
							if (this.#finish[3]) {
								break;
							}
							return;
						}
						else if (this.#finish[i] != true) {
							return;
						}
					}
					++this.#index;
					this.#finish[0] = false;
					this.#option_target = null;
					if (this.#index < 0 || this.#index >= this.#data_id.length) {
						this.#index = -1;
						this.clearContent();
						this.showCover(false);
						return;
					}
					let tk_id = this.#data_id[this.#index][0];
					this.#data = database.getRecord("talk", tk_id, 0);
					let ch_id = database.getRecord("talk_character", tk_id, 1);
					if (ch_id != null) {
						ch_id = ch_id[2];
						ch_id = database.getRecord("character", ch_id, 0);
					}
					if (ch_id != null) {
						ch_id = ch_id[2];
					}
					this.#components.talk_name.innerText = ch_id;
					this.#components.talk_content.innerText = "";
					
					this.decodeData(this.#data);
				}
				
				fullScreen() {
					if (document.fullscreenElement == this.#container) {
						document.exitFullscreen();
						this.#container.removeAttribute("style");
					}
					else if (document.fullscreenElement == null) {
						this.#container.requestFullscreen();
						// let width = screen.width;
						// let height = screen.height;
						// width += "px;height:" + height + "px;";
						// this.#container.setAttribute("style", "width:" + width);
					}
				}
				
				// 选择一个选项
				async selectOption(index, content) {
					// console.log("选择选项");
					// console.log(this.#data);
					let type = this.#data[1];
					
					if (type != d_DataEnum.OPTION) {
						return false;
					}
					// console.log(this.#option_target);
					if (this.#option_target == null) {
						// console.log("生成跳转目标");
						this.#option_target = this.#decodeChapterFunction(this.#data[6], this.#data[3]);
					}
					// console.log("类型：" + this.#option_target[index]);
					// -2表示不跳转，-1表示不允许继续
					if (this.#option_target[index] == -1) {
						return false;
					}
					else if (this.#option_target[index] == -2) {
						this.#decodeOperationFunction(this.#data[5], index);
						if (content != null) {
							this.#addHistory("选择选项", content);
						}
						this.toNext(0);
						return true;
					}
					// console.log("通过检验");
					this.#decodeOperationFunction(this.#data[5], index);
					this.#components.option.innerHTML = "";
					let code = this.loadChapter(this.#option_target[index]);
					if (code != null) {
						alert(code);
						return false;
					}
					if (content != null) {
						this.#addHistory("选择选项", content);
					}
					this.#components.option.setAttribute("style", "display:none;");
					this.#finish[0] = false;
					this.toNext(3);
					this.toNext(0);
					return true;
				}
				
				async loadChapterView() {
					this.#components.chapter_view.setAttribute("hidden", true);
					let str = database.select("advanced_param", "data", "name=chapter_view");
					if (str.length == 0) {
						return;
					}
					else {
						str = str[0][0];
					}
					let data = this.#parseChapterRelationData(str);
					if (data == null) {
						// alert("参数错误");
						return;
					}
					let img = null;
					let resource_id = database.select("advanced_param", "data", "name=chapter_view_resource");
					if (resource_id.length != 0) {
						resource_id = resource_id[0][0];
					}
					else {
						resource_id = "";
					}
					this.#components.chapter_view.children[1].setAttribute("hidden", true);
					// console.log(this.#components.chapter_view.children[1].getAttribute("hidden"))
					let div = this.#components.chapter_view_content;
					img = await this.#createImage(["", "", resource_id, "", "", "", "", ""]);
					this.#createChapterRelationView(data, div, 16/9, img);
					this.#chapter_view_param.update = true;
					// console.log(this.#components.chapter_view.children[1].getAttribute("hidden"))
				}
				
				showChapterView() {
					if (this.#components.chapter_view.hasAttribute("hidden")) {
						this.#components.chapter_view.removeAttribute("hidden");
						this.autoPlay(0);
						if (this.#chapter_view_param.update) {
							this.#chapter_view_param.update = false;
							if (this.#components.chapter_view_scroll == null) {
								let item = new d_ScrollPanel(this.#components.chapter_view, 0);
								item.hideBar(1);
								item.setAnchor("left", "mid");
								this.#components.chapter_view_scroll = item;
							}
							this.#components.chapter_view_scroll.reset();
							this.#components.chapter_view_scroll.scrollTo("lm");
						}
						this.#scene_tools.progress.setAttribute("selected", true);
						this.hideHistory();
					}
					else {
						this.hideChapterView();
					}
				}
				
				hideChapterView() {
					this.#components.chapter_view.setAttribute("hidden", true);
					this.#scene_tools.progress.removeAttribute("selected");
				}
				
				showHistory() {
					if (this.#components.history.hasAttribute("hidden")) {
						this.#components.history.removeAttribute("hidden");
						this.autoPlay(0);
						if (this.#history_param.update) {
							this.#history_param.update = false;
							if (this.#components.history_scoll == null) {
								let item = new d_ScrollPanel(this.#components.history, 0);
								item.hideBar(0);
								item.setZoom(false);
								item.setAnchor("mid", "bottom");
								this.#components.history_scoll = item;
							}
							this.#components.history_scoll.reset();
							this.#components.history_scoll.scrollTo("mb");
						}
						this.#scene_tools.history.setAttribute("selected", true);
						this.hideChapterView();
					}
					else {
						this.hideHistory();
					}
				}
				
				hideHistory() {
					this.#components.history.setAttribute("hidden", true);
					this.#scene_tools.history.removeAttribute("selected");
				}
				
				autoPlay(type) {
					let cur_type = this.#auto_play_param.type;
					if (type == 1) {
						if (cur_type < 3) {
							++cur_type;
						}
						else {
							cur_type = 0;
						}
					}
					else if (type == cur_type) {
						cur_type = 0;
					}
					else {
						cur_type = type;
					}
					if (cur_type > 0) {
						this.hideChapterView();
						this.hideHistory();
					}
					this.#auto_play_param.type = cur_type;
					if (cur_type == 0) {
						this.#auto_play_param.click_time = "none";
						this.#auto_play_param.click_delay = 1000;
						this.#scene_tools.skip.removeAttribute("selected");
						this.#scene_tools.auto_play.removeAttribute("selected");
						this.#scene_tools.auto_play.innerText = "自动播放";
					}
					else if (cur_type == 1) {
						this.#auto_play_param.click_time = "after";
						this.#auto_play_param.click_delay = 1000;
						this.#auto_play_param.click_delay_factor = 50;
						this.#scene_tools.auto_play.setAttribute("selected", true);
						this.#scene_tools.auto_play.innerText = "自动播放>";
						this.#scene_tools.skip.removeAttribute("selected");
					}
					else if (cur_type == 2) {
						this.#auto_play_param.click_time = "after";
						this.#auto_play_param.click_delay = 500;
						this.#auto_play_param.click_delay_factor = 20;
						this.#scene_tools.auto_play.setAttribute("selected", true);
						this.#scene_tools.auto_play.innerText = "自动播放>>";
						this.#scene_tools.skip.removeAttribute("selected");
					}
					else if (cur_type == 3) {
						this.#auto_play_param.click_time = "after";
						this.#auto_play_param.click_delay = 300;
						this.#auto_play_param.click_delay_factor = 5;
						this.#scene_tools.auto_play.setAttribute("selected", true);
						this.#scene_tools.auto_play.innerText = "自动播放>>>";
						this.#scene_tools.skip.removeAttribute("selected");
					}
					else if (cur_type == 4) {
						this.#auto_play_param.click_time = "all";
						this.#scene_tools.skip.setAttribute("selected", true);
						this.#scene_tools.auto_play.removeAttribute("selected");
						this.#scene_tools.auto_play.innerText = "自动播放";
					}
					clearInterval(this.#auto_play_param.thread);
					this.#auto_play_param.timer = -1;
					this.#auto_play_param.working = false;
					if (cur_type == 0) {
						return;
					}
					
					let self = this;
					this.#auto_play_param.thread = setInterval(function() {
						let param = self.#auto_play_param;
						if (param.click_time == "all") {
							self.toNext(0);
						}
						else if (param.click_time == "after") {
							// 在刚进入自动播放时的第一帧：
							// 如果文字已经演示完毕，就直接进入下一幕
							// 如果这一幕不是文字动画，就等待下一幕
							// 否则，正常运行
							if (!param.working) {
								self.#auto_play_param.working = true;
								if (self.#text_thread == null && param.text_played) {
									self.#auto_play_param.text_played = false;
									self.#auto_play_param.timer = -1;
									self.toNext(0);
									// console.log("等待当前阻塞进程或跳过当前一幕");
									return;
								}
								// console.log("等待当前文字演示");
							}
							// 如果正在播放文字，就等待
							else if (self.#text_thread != null || !param.text_played) {
								// console.log("等待当前文字演示");
								return;
							}
							// 如果正在播放语音，就等待
							else if (param.audio_playing_depth >= 0) {
								let struct = self.#audio_control.get(param.audio_playing_depth);
								if (struct == null) {
									self.#auto_play_param.audio_playing_depth = -1;
								}
								else if(!struct.working && struct.dom.paused) {
									self.#auto_play_param.audio_playing_depth = -1;
								}
								// console.log("等待当前语音结束" + param.audio_playing_depth);
								return;
							}
							else if (param.timer < 0) {
								self.#auto_play_param.timer = new Date().getTime();
								// console.log("开始计时");
								return;
							}
							else {
								let offset = new Date().getTime() - param.timer;
								let target = param.click_delay;
								if (offset >= param.click_delay + param.click_delay_factor * param.text_length) {
									self.#auto_play_param.timer = -1;
									self.#auto_play_param.text_played = false;
									self.toNext(0);
									// console.log("切换");
								}
							}
						}
					}, 30);
				}
				
				downloadProgress() {
					let data = localStorage.getItem("el_play");
					if (data == null || data.length == 0) {
						this.popInfo("生成存档文件失败", "暂无需要记录的数据。", 2000);
					}
					let writer = new d_BinaryWriter();
					writer.addString(data);
					
					let link = document.createElement("a");
					link.download = "elStore" + this.#work_info.name + new Date().getTime() + ".el";
					link.href = window.URL.createObjectURL(writer.getBlob());
					link.click();
					link.remove();
				}
				
				async decodeData(data) {
					let type = data[1];
					if (type > d_DataEnum.MID_TEXT && type <= d_DataEnum.MID_IMAGE) {
						
						let new_dom = await this.#createImage(data);
						if (data[5] < 0) {
							for (let i = 0; i < this.#image_keys.length; ++i) {
								let t_data = [];
								for (let j = 0; j < data.length; ++j) {
									t_data.push(data[j]);
								}
								t_data[5] = this.#image_keys[i];
								this.decodeData(t_data);
							}
							return;
						}
						
						this.#finish[2] = false;
						let debug_str = "轨道" + data[5];
						this.logImage(debug_str + "加载资源：" + data[2]);
						
						// 如果该轨道已经有对象，进行交换
						let struct = this.#image_control.get(data[5]);
						if (struct != null) {
							// 如果该轨道正在进行渐变交换，直接叫停
							if (struct.working) {
								this.logImage(debug_str + "截断");
								this.#imageThreadFunction(data[5]);
							}
							else {
								this.logImage(debug_str + "交接");
							}
						}
						// 否则，新建一个控制单元
						else {
							this.logImage(debug_str + "交接");
							struct = {
								// 正在进行对象切换
								working: true,
								// 需要保存至玩家进度
								progress: false,
								// 不需要将该轨道移除
								need_remove: false,
								depth: -1,
								talk_id: -1,
								dom: null,
								new_dom: null,
								speed: -1,
								percent: 0
							}
						}
						let component = this.#components.background;
						
						struct.working = true;
						if (new_dom.src != null && new_dom.src.length != 0) {
							struct.progress = true;
						}
						else {
							struct.progress = false;
						}
						struct.need_remove = false;
						struct.depth = data[5];
						struct.percent = 0;
						struct.talk_id = data[0];
						struct.new_dom = new_dom;
						struct.new_dom.style.opacity = 0;
						let time = parseInt(data[6]);
						if (!isNaN(time) && time > 0) {
							struct.speed = 10 / time;
						}
						else {
							struct.speed = -1;
						}
						struct.dom = this.#insertElementByDepth(component, struct.new_dom, data[5]);
						
						// 加入循环队列
						this.#image_control.set(data[5], struct);
						this.#image_keys = Array.from(this.#image_control.keys());
						
						this.logImage(debug_str + "开始工作");
						// 唤醒控制线程
						if (this.#image_thread == null) {
							let self = this;
							this.logImage("线程唤醒：轨道" + struct.depth);
							self.#imageThreadFunction();
							this.#image_thread = setInterval(function() {
								self.#imageThreadFunction();
							}, 10);
						}
					}
					else if (type <= d_DataEnum.MID_AUDIO) {
						let struct = null;
						// 播放语音
						if (type >= d_DataEnum.LEFT_AUDIO) {
							// 等待加载音频
							let new_dom = await this.#createAudio(data);
							if (data[5] < 0) {
								for (let i = 0; i < this.#audio_keys.length; ++i) {
									let t_data = [];
									for (let j = 0; j < data.length; ++j) {
										t_data.push(data[j]);
									}
									t_data[5] = this.#audio_keys[i];
									this.decodeData(t_data);
								}
								return;
							}
							
							let debug_str = "轨道" + data[5];
							this.logAudio(debug_str + "加载资源：" + data[4]);
							
							// 如果该音轨已经有音频，进行交换
							struct = this.#audio_control.get(data[5]);
							if (struct != null) {
								// 如果该音轨正在进行渐变交换，直接叫停
								if (struct.working) {
									this.logAudio(debug_str + "截断");
									this.#audioThreadFunction(data[5]);
								}
								else {
									this.logAudio(debug_str + "交接");
								}
							}
							// 否则，新建一个控制单元
							else {
								this.logAudio(debug_str + "交接");
								struct = {
									// 正在进行音频切换
									working: true,
									// 需要保存至玩家进度
									progress: false,
									// 不需要将该音轨移除
									need_remove: false,
									// 是否是背景音乐
									background: false,
									depth: -1,
									talk_id: -1,
									dom: null,
									new_dom: null,
									speed: -1,
									percent: 0
								}
							}
							let component = this.#components.sound;
							
							struct.working = true;
							if (new_dom.src != null && new_dom.src.length != 0) {
								struct.progress = true;
							}
							else {
								struct.progress = false;
							}
							if (type == d_DataEnum.MID_AUDIO) {
								struct.background = true;
							}
							else {
								struct.background = false;
							}
							struct.need_remove = false;
							struct.depth = data[5];
							struct.percent = 0;
							struct.talk_id = data[0];
							struct.new_dom = new_dom;
							let time = parseInt(data[6]);
							if (!isNaN(time) && time > 0) {
								struct.speed = 20 / time;
							}
							else {
								struct.speed = -1;
							}
							if (struct.dom != null) {
								this.#insertElementByDepth(component, struct.new_dom, struct.depth);
							}
							else {
								struct.dom = this.#insertElementByDepth(component, struct.new_dom, struct.depth);
							}
							if (struct.new_dom.duration > 0) {
								struct.new_dom.play();
							}
							
							// 加入循环队列
							this.#audio_control.set(struct.depth, struct);
							this.#audio_keys = Array.from(this.#audio_control.keys());
							
							this.logAudio(debug_str + "开始工作");
							// 唤醒音频控制线程
							if (this.#audio_thread == null) {
								let self = this;
								this.logAudio("线程唤醒：轨道" + struct.depth);
								self.#audioThreadFunction();
								this.#audio_thread = setInterval(function() {
									self.#audioThreadFunction();
								}, 20);
							}
						}
						// 背景音乐不阻塞
						if (type == d_DataEnum.MID_AUDIO) {
							this.toNext(0);
						}
						// 显示文字（背景音乐不显示）
						if (type < d_DataEnum.MID_AUDIO) {
							this.#finish[1] = false;
							let self = this;
							this.#textIndex = 0;
							
							if (this.#text_thread != null) {
								clearInterval(this.#text_thread);
								return;
							}
							if (struct != null) {
								this.#auto_play_param.audio_playing_depth = struct.depth;
							}
							
							// 将文字加入历史记录
							this.#addHistory(this.#components.talk_name.innerText, data[2]);
							
							self.#textThreadFunction();
							this.#text_thread = setInterval(function() {
								self.#textThreadFunction();
							}, 60);
						}
					}
					// 选项
					else if (type <= d_DataEnum.OPTION) {
						let component = this.#components.option;
						component.innerHTML = "";
						let count = parseInt(data[3]);
						let text = data[2].split(';');
						if (isNaN(count) || count <= 0 || count > 4) {
							return;
						}
						if (data[2].trim().length != 0 && text.length != count) {
							return;
						}
						data[3] = count;
						let enabled_index = this.#decodeOptionFunction(data[7], count);
						let img = await this.#createImage(["", "", data[4], "", "origin", "", "", "cm"]);
						// 如果是空的，就自动执行
						if (img.src == null || img.src.length == 0) {
							for (let i = 0; i < enabled_index.length; ++i) {
								if (!enabled_index[i]) {
									continue;
								}
								if (this.selectOption(i)) {
									return;
								}
							}
							this.toNext(0);
							// this.toNext(0);
						}
						else {
							let style = img.getAttribute("style");
							let first = true;
							let contents = data[2].split(';');
							img.removeAttribute("style");
							for (let i = 0; i < enabled_index.length; ++i) {
								if (enabled_index[i]) {
									let div = document.createElement("div");
									let p = document.createElement("p");
									let content_slice = "";
									if (i < contents.length) {
										content_slice = contents[i];
									}
									p.innerText = text[i];
									if (!first) {
										img = img.cloneNode();
									}
									div.appendChild(img);
									div.appendChild(p);
									div.setAttribute("onclick", "scene_panel.selectOption(" + i + ",\"" + content_slice + "\");");
									div.setAttribute("style", style);
									component.appendChild(div);
									first = false;
								}
							}
							if (first) {
								this.toNext(0);
							}
							else {
								this.#finish[3] = false;
							}
							let piece = 60 / component.childElementCount;
							for (let i = 0; i < component.childElementCount; ++i) {
								component.children[i].style.top = (10 + piece * (i + 0.5)) + "%";
							}
							component.removeAttribute("style");
						}
					}
					
				}
				
				async #createImage(data) {
					let res = document.createElement("img");
					let flag = false;
					let path = null;
					if (data[2] != null && data[2].trim() != "") {
						path = database.getRecord("resource", data[2], 0)[2];
						if (path != "") {
							flag = true;
						}
					}
					if (!flag) {
						return res;
					}
					let width = 0;
					await new Promise(function(resolve) {
						res.onload = () => {
							resolve(res.width);
						};
						res.src = path;
					}).then(result => {
						width = result;
					});
					// 返回空图片
					if (width == 0) {
						res.removeAttribute("src");
						return res;
					}
					
					let style_data = "";
					let param = data[4];
					if (param == "origin") {
						style_data += "width:" + (width / 19.2) + "%;";
					}
					else if (param == "fill") {
						style_data += "width:100%;height:100%;";
					}
					param = data[7];
					if (param.length != 2) {
						res.setAttribute("style", style_data);
						return res;
					}
					let cx = false;
					let cy = false;
					if (param[0] == "l") {
						style_data += "left:0;";
					}
					else if (param[0] == "c") {
						style_data += "left:50%;";
						cx = true;
					}
					else if (param[0] == "r") {
						style_data += "right:0;";
					}
					if (param[1] == "t") {
						style_data += "top:0;";
					}
					else if (param[1] == "m") {
						style_data += "top:50%;";
						cy = true;
					}
					else if (param[1] == "b") {
						style_data += "bottom:0;";
					}
					if (cx && cy) {
						style_data += "transform:translate(-50%,-50%);";
					}
					else if (cx) {
						style_data += "transform:translateX(-50%);";
					}
					else if (cy) {
						style_data += "transform:translateY(-50%);";
					}
					res.setAttribute("style", style_data);
					return res;
				}
				
				async #createAudio(data) {
					let res = document.createElement("audio");
					let flag = false;
					let path = null;
					if (data[4] != null && data[4].trim() != "") {
						path = database.getRecord("resource", data[4], 0)[2];
						if (path != "") {
							flag = true;
						}
					}
					if (!flag) {
						return res;
					}
					let duration = 0;
					await new Promise(function(resolve) {
						res.onloadedmetadata = () => {
							resolve(res.duration);
						};
						res.src = path;
					}).then(result => {
						duration = result;
					});
					// 返回空对象
					if (duration == 0) {
						res.removeAttribute("src");
						return res;
					}
					let param = data[7];
					if (param == "1") {
						res.loop = true;
					}
					return res;
				}
				
				#insertElementByDepth(parent, item, depth) {
					let index = 0;
					let target = null;
					for ( ; index < parent.childElementCount; ++index) {
						let child = parent.children[index];
						if (!child.hasAttribute("depth")) {
							continue;
						}
						let c_depth = child.getAttribute("depth");
						if (c_depth == depth) {
							target = child;
							++index;
							break;
						}
						else if (c_depth > depth) {
							break;
						}
					}
					
					// 追加
					if (index >= parent.childElementCount) {
						parent.appendChild(item);
					}
					// 插入
					else {
						parent.insertBefore(item, parent.children[index]);
					}
					return target;
				}
				
				#textThreadFunction() {
					let index = this.#index;
					let text = this.#data[2];
					++this.#textIndex;
					this.#auto_play_param.text_played = true;
					this.#auto_play_param.text_length = text.length;
					if (this.#textIndex > text.length) {
						clearInterval(this.#text_thread);
						this.#text_thread = null;
						this.toNext(1);
						return;
					}
					else if (this.#finish[0]) {
						this.#finish[0] = false;
						this.#components.talk_content.innerText = text;
						clearInterval(this.#text_thread);
						this.#text_thread = null;
						this.toNext(1);
						return;
					}
					this.#components.talk_content.innerText = text.slice(0, this.#textIndex);
				}
				
				#imageThreadFunction(forced_shut_down) {
					let sleep = true;
					let remove_arr = [];
					for (let i = 0; i < this.#image_keys.length; ++i) {
						let key = this.#image_keys[i];
						let shut = false;
						if (forced_shut_down == key) {
							shut = true;
						}
						else if (forced_shut_down != null) {
							continue;
						}
						let struct = this.#image_control.get(key);
						// 无需切换图片，就逃过
						if (!struct.working) {
							continue;
						}
						sleep = false;
						struct = this.#imageThreadFunction1(key, struct, shut);
						if (struct.need_remove) {
							remove_arr.push(key)
						}
						else {
							if (!struct.working) {
								this.logImage("轨道" + struct.depth + "进入休眠");
							}
							this.#image_control.set(key, struct);
						}
						
						// 完成图片切换后，加载下一幕
						if (!struct.working) {
							this.toNext(2);
						}
					}
					if (remove_arr.length != 0) {
						for (let i = 0; i < remove_arr.length; ++i) {
							this.logImage("移除轨道" + key);
							this.#image_control.delete(remove_arr.length[i]);
						}
						this.#image_keys = Array.from(this.#image_control.keys());
					}
					if (sleep) {
						this.logImage("线程休眠");
						clearInterval(this.#image_thread);
						this.#image_thread = null;
					}
				}
				
				#imageThreadFunction1(depth, struct, forced_shut_down) {
					// 渐变
					if (struct.speed > 0) {
						struct.percent += struct.speed;
					}
					else {
						struct.percent = 2;
					}
					
					// 结束
					if (struct.percent >= 1 || forced_shut_down) {
						if (struct.dom != null) {
							struct.dom.remove();
						}
						// 新来的是空对象，就关闭这一轨道
						if (struct.new_dom.src == null) {
							struct.working = false;
							struct.need_remove = true;
						}
						// 否则，该轨道进入休眠
						else {
							struct.working = false;
						}
						
						struct.new_dom.setAttribute("depth", depth);
						struct.new_dom.style.opacity = 1;
						struct.dom = struct.new_dom;
						struct.new_dom = null;
						return struct;
					}
					if (struct.dom != null) {
						struct.dom.style.opacity = 1 - struct.percent;
					}
					
					// 图片不能通过点击跳过
					if (this.#finish[0]) {
						this.#finish[0] = false;
					}
					struct.new_dom.style.opacity = struct.percent;
					return struct;
				}
				
				#audioThreadFunction(forced_shut_down) {
					let sleep = true;
					let remove_arr = [];
					for (let i = 0; i < this.#audio_keys.length; ++i) {
						let key = this.#audio_keys[i];
						let shut = false;
						if (forced_shut_down == key) {
							shut = true;
						}
						else if (forced_shut_down != null) {
							continue;
						}
						let struct = this.#audio_control.get(key);
						// 无需切换音频，就逃过
						if (!struct.working) {
							continue;
						}
						sleep = false;
						struct = this.#audioThreadFunction1(key, struct, shut);
						if (struct.need_remove) {
							remove_arr.push(key)
						}
						else {
							if (!struct.working) {
								this.logAudio("轨道" + struct.depth + "进入休眠");
							}
							this.#audio_control.set(key, struct);
						}
					}
					if (remove_arr.length != 0) {
						for (let i = 0; i < remove_arr.length; ++i) {
							this.logAudio("移除音频轨道" + remove_arr[i]);
							this.#audio_control.delete(remove_arr[i]);
						}
						this.#audio_keys = Array.from(this.#audio_control.keys());
					}
					if (sleep) {
						this.logAudio("线程休眠");
						clearInterval(this.#audio_thread);
						this.#audio_thread = null;
					}
				}
				
				#audioThreadFunction1(depth, struct, forced_shut_down) {
					// 渐变
					if (struct.speed > 0) {
						struct.percent += struct.speed;
					}
					else {
						struct.percent = 2;
					}
					// this.logAudio("轨道" + struct.depth + "进度：" + struct.percent);
					// this.logAudio("轨道" + struct.depth + "时长：" + struct.new_dom.duration);
					
					// 结束
					if (struct.percent >= 1 || forced_shut_down) {
						if (forced_shut_down) {
							this.logAudio("轨道" + struct.depth + "任务截断");
						}
						else {
							this.logAudio("轨道" + struct.depth + "任务完成");
						}
						if (struct.dom != null) {
							struct.dom.remove();
						}
						
						// 新来的是空音频，就关闭这一音轨
						if (struct.new_dom.src == null) {
							struct.working = false;
							struct.need_remove = true;
						}
						// 否则，该音轨进入休眠
						else {
							struct.working = false;
						}
						
						struct.new_dom.setAttribute("depth", depth);
						struct.new_dom.volume = 1;
						struct.dom = struct.new_dom;
						struct.new_dom = null;
						return struct;
					}
					if (struct.dom != null) {
						struct.dom.volume = 1 - struct.percent;
					}
					
					struct.new_dom.volume = struct.percent;
					return struct;
				}
				
				// 通过变量名获取变量的值
				#getParameterValue(str) {
					let res = parseInt(str);
					if (!isNaN(res)) {
						return res;
					}
					
					if (this.#param_map.has(str)) {
						return this.#param_map.get(str);
					}
					this.#param_map.set(str, 0);
					return 0;
				}
				
				// 通过变量名设置变量的值
				#setParameterValue(str, value) {
					let res = parseInt(str);
					if (!isNaN(res)) {
						return;
					}
					this.#param_map.set(str, value);
				}
				
				// 严格地将一个字符串转为数字
				// 如果字符串中包含非数字，则返回 NaN
				#strictParseInt(str) {
					if (str == null || str == NaN) {
						return NaN;
					}
					if (typeof str != "string") {
						return NaN;
					}
					let res = parseInt(str);
					if (isNaN(res)) {
						return NaN;
					}
					if (res.toString().length != str.length) {
						return NaN;
					}
					return res;
				}
				
				// 判断每个选项应该跳转到哪个章节
				// 输出一个数组，每一项为点击该选项应该跳转的章节序号，-1表示出错
				#decodeChapterFunction(str, count) {
					// [1, 2, 3, 4]
					let conditions = this.#splitStringValid(str, count);
					let res = new Array();
					if (count != null && conditions.length != count) {
						for (let i = 0; i < count; ++i) {
							res.push(-1);
						}
						return res;
					}
					// 语句循环
					for (let i = 0; i < conditions.length; ++i) {
						// [1.1, 1.2, 1.3, 1.4]
						let condit = conditions[i].split(',');
						let match = -1;
						// 空项，不进行场景跳转
						if (condit.length == 1 && condit[0].trim().length == 0) {
							res.push(-2);
							continue;
						}
						// 子语句循环
						for (let j = 0; j < condit.length && match < 0; ++j) {
							// 无条件跳转场景
							let data_slice = this.#strictParseInt(condit[j]);
							if (!isNaN(data_slice)) {
								match = data_slice;
								// console.log("无条件");
								continue;
							}
							let eq_index = condit[j].indexOf('=');
							if (eq_index <= 0 || eq_index >= condit[j].length - 1) {
								match = -1;
								// console.log("等号位置有误");
								continue;
							}
							// 1=score=3
							data_slice = [null, null];
							
							// 章节序号必须是数字
							data_slice[0] = condit[j].substring(0, eq_index);
							data_slice[0] = this.#strictParseInt(data_slice[0]);
							if (isNaN(data_slice[0])) {
								match = -1;
								// console.log("章节非数字：" + data_slice[0]);
								continue;
							}
							// 条件
							data_slice[1] = condit[j].substring(eq_index + 1);
							// if 1.1 == reg?
							if (this.#checkConditionFulfilled(data_slice[1])) {
								match = data_slice[0];
								break;
							}
						}
						res.push(match);
					}
					return res;
				}
				
				// 进行变量修饰，指定运行第index个选项的结果
				#decodeOperationFunction(str, index) {
					let op = this.#splitStringValid(str);
					if (index >= op.length) {
						return;
					}
					op = op[index].split(',');
					let reg = ["=", "+", "-", "*", "/", "%", "~"];
					for (let i = 0; i < op.length; ++i) {
						let data = op[i];
						if (data.length == 0) {
							continue;
						}
						for (let j = 0; j < reg.length; ++j) {
							let value = this.#splitBySymbol(data, reg[j]);
							if (value == null) {
								continue;
							}
							let res = this.#operate(value[0], value[1], reg[j]);
							this.#setParameterValue(value[2], res);
						}
					}
				}
				
				// 判断选项是否应该出现
				#decodeOptionFunction(str, count) {
					// [1, 2, 3, 4]
					let conditions = this.#splitStringValid(str, count);
					let res = new Array();
					if (count != null && conditions.length != count) {
						for (let i = 0; i < count; ++i) {
							res.push(true);
						}
						return res;
					}
					for (let i = 0; i < conditions.length; ++i) {
						if (this.#checkConditionFulfilled(conditions[i])) {
							res.push(true);
						}
						else {
							res.push(false);
						}
					}
					return res;
				}
				
				// 将字符串以分号;分隔
				// 判断参数字符串是否合法
				#splitStringValid(str, count) {
					if (str == null || str.length == 0 || str.length > 200) {
						return [""];
					}
					// [1, 2, 3, 4]
					let res = str.split(';');
					if (count != null && res.length != count) {
						return [""];
					}
					return res;
				}
				
				// 判断条件 变量 逻辑运算符 变量 是否合法且成立
				#checkConditionFulfilled(condition) {
					if (condition.trim().length == 0) {
						return true;
					}
					let reg = ["<=", ">=", "<", ">", "=", "!"];
					for (let i = 0; i < reg.length; ++i) {
						let value = this.#splitBySymbol(condition, reg[i]);
						if (value == null) {
							continue;
						}
						// 匹配
						if (this.#judgeCondition(value[0], value[1], reg[i])) {
							// console.log("满足条件：" + reg[i]);
							return true;
						}
						return false;
					}
					return false;
				}
				
				// 判断 num1 judge num2 条件是否成立
				#judgeCondition(num1, num2, judge) {
					// console.log(num1 + judge + num2);
					if (judge == "<=" && num1 <= num2) {
						return true;
					}
					else if (judge == ">=" && num1 >= num2) {
						return true;
					}
					else if (judge == "<" && num1 < num2) {
						return true;
					}
					else if (judge == ">" && num1 > num2) {
						return true;
					}
					else if (judge == "=" && num1 == num2) {
						return true;
					}
					else if (judge == "!" && num1 != num2) {
						return true;
					}
					return false;
				}
				
				#splitBySymbol(str, symbol) {
					let data = str.split(symbol);
					if (data.length == 1) {
						// console.log("未匹配：" + symbol);
						return null;
					}
					else if (data.length > 2) {
						// console.log("变量名异常：" + symbol);
						return null;
					}
					data[0] = data[0].trim();
					data[1] = data[1].trim();
					// console.log("左值：" + data[0] + "，右值：" + data[1]);
					if (data[0].length == 0 || data[1].length == 0) {
						// console.log("值为空");
						return null;
					}
					let v1 = this.#getParameterValue(data[0]);
					let v2 = this.#getParameterValue(data[1]);
					return [v1, v2, data[0]];
				}
				
				
				// 将运算的结果返回
				#operate(num1, num2, op) {
					// console.log(num1 + op + num2);
					if (op == "=") {
						return num2;
					}
					else if (op == "+") {
						return num1 + num2;
					}
					else if (op == "-") {
						return num1 - num2;
					}
					else if (op == "*") {
						return num1 * num2;
					}
					else if (op == "/") {
						let res = Math.round((num1 / num2) * 100);
						res = Math.floor(res / 100);
						return res;
					}
					else if (op == "%") {
						return num1 % num2;
					}
					else if (op == "~") {
						if (num1 == num2) {
							return num2;
						}
						let range = Math.abs(num1 - num2);
						return Math.floor((Math.random() * range));
					}
					return 0;
				}
				
				#parseChapterRelationData(str) {
					if (str == null) {
						return null;
					}
					if (typeof str != "string" || str.length == 0) {
						return null;
					}
					let locked_id_map = new Map();
					let hidden_id_map = new Map();
					let error_id_map = new Map();
					
					// 语句：……;[章节序号,文字描述,后接章节的上至下位次]（多组）;……
					// 文字描述中可能含有逗号，所以文字描述中的逗号前必须加反斜杠，以标识这是普通字符
					let res = [];
					let data = d_Tool.splitString(str, ';');
					// 最多行元素那一列的行数
					let max_row_count = 1;
					for (let i = 0; i < data.length; ++i) {
						// 含有这一列的所有行元素
						// console.log("检查列" + i);
						let data_slice = d_Tool.splitString(data[i], ',');
						// console.log(data_slice);
						// 三个一组，检查是否不符合要求
						if (data_slice.length == 0 || data_slice.length % 3 != 0) {
							console.log("数据格式有误");
							return null;
						}
						
						// 计算这一列有几行
						let row_count = data_slice.length / 3;
						
						for (let j = 0; j < data_slice.length; ++j) {
							// 章节序号
							if (j % 3 == 0) {
								data_slice[j] = parseInt(data_slice[j]);
								if (isNaN(data_slice[j])) {
									// console.log("数据格式有误");
									return null;
								}
								let chapter = database.select("chapter", "*", "id=" + data_slice[j]);
								if (chapter.length == 0) {
									error_id_map.set(data_slice[j], []);
									continue;
								}
								// if (chapter[0][2] != "begin") {
									locked_id_map.set(data_slice[j], []);
								// }
								if (chapter[0][2] == "hide") {
									hidden_id_map.set(data_slice[j], []);
								}
							}
							// 后接章节位次
							if (j % 3 == 2) {
								if (data_slice[j].trim().length == 0) {
									data_slice[j] = [];
									continue;
								}
								data_slice[j] = d_Tool.splitString(data_slice[j], '.');
								for (let loop = 0; loop < data_slice[j].length; ++loop) {
									data_slice[j][loop] = parseInt(data_slice[j][loop]);
									if (isNaN(data_slice[j][loop])) {
										// console.log("数据格式有误");
										return null;
									}
								}
								
							}
						}
						res.push(data_slice);
						if (row_count > max_row_count) {
							max_row_count = row_count;
						}
					}
					// 格式：[列元素][列元素]……[列元素][最大行数]
					res.push(max_row_count);
					this.#chapter_view_param.locked_id_map = locked_id_map;
					this.#chapter_view_param.hidden_id_map = hidden_id_map;
					this.#chapter_view_param.error_id_map = error_id_map;
					return res;
				}
				
				#createChapterRelationView(data, target_panel, parent_ratio, img) {
					// img = img.cloneNode();
					target_panel.innerHTML = "";
					if (data == null) {
						return;
					}
					let padding = {
						x: 300,
						y: 200,
					};
					let canvas_size = {
						x: 0,
						y: 0
					}
					let piece_size = {
						width: 500,
						height: 80,
						width_space: 200,
						height_space: 160
					};
					//缩放
					let zoom = 1;
					
					// 图片可以正常显示
					// 就定好宽度，原比例缩放图片
					if (img != null && img.width != 0 && img.height != 0) {
						piece_size.height = Math.round(piece_size.width / img.width * img.height);
					}
					let column_count = data.length - 1;
					let max_row_count = data[data.length - 1];
					// 根据行数、列数、单个图片长宽、padding、间隔确定画布大小
					canvas_size.x = 2 * padding.x + column_count * (piece_size.width + piece_size.width_space);
					target_panel.style.width = (zoom * canvas_size.x / 19.20) + "%";
					canvas_size.y = 2 * padding.y + max_row_count * (piece_size.height + piece_size.height_space);
					target_panel.style.height = (zoom * canvas_size.y / 19.20 * parent_ratio) + "%";
					
					// 将宽度和高度转为targe_panel现在尺寸下的比例
					piece_size.width = 100 * piece_size.width / canvas_size.x;
					piece_size.height = 100 * piece_size.height / canvas_size.y;
					piece_size.width_space = 100 * piece_size.width_space / canvas_size.x;
					piece_size.height_space = 100 * piece_size.height_space / canvas_size.y;
					padding.x = 100 * padding.x / canvas_size.x;
					padding.y = 100 * padding.y / canvas_size.y;
					
					let param = this.#chapter_view_param;
					let background = img;
					background.setAttribute("draggable", "false");
					let first = false;
					// 记录这一列的连接请求，键为下一列的上至下位次，值为这一列请求连接的行元素的偏移位次
					let connect_request = new Map();
					// 记录前一列的连接请求，键为这一列的上至下位次，值为上一列请求连接的行元素的偏移位次
					let former_connect_request = new Map();
					// 以列为单位，对每列进行处理
					for (let i = 0; i < data.length - 1; ++i) {
						// [章节序号,文字描述,后接章节的上至下位次] 循环
						let data_slice = data[i];
						let row_count = data[i].length / 3;
						for (let j = 0; j < data_slice.length; j += 3) {
							if (first) {
								background = img.cloneNode();
							}
							let row_index = Math.round(j / 3);
							// 偏移位次，用于计算行元素垂直位置
							let offset_index = row_index - (row_count - 1) / 2;
							let chapter_type = "normal";
							// 章节不存在
							if (param.error_id_map.has(data_slice[j])) {
								chapter_type = "error";
							}
							// 是否是隐藏章节
							else if (param.locked_id_map.has(data_slice[j])) {
								if (param.hidden_id_map.has(data_slice[j])) {
									chapter_type = "hide";
								}
								else {
									chapter_type = "lock";
								}
							}
							
							let offset = {
								left_space: piece_size.width_space / 2 + padding.x,
								top_space: 50,
								left_unit: piece_size.width + piece_size.width_space,
								top_unit: piece_size.height + piece_size.height_space,
								width: 0,
								height: 0,
								ratio: canvas_size.y / canvas_size.x,
								hypotenuse: 0,
								deg: 0
							}
							
							let hidden_array = param.hidden_id_map.get(data_slice[j]);
							let locked_array = param.locked_id_map.get(data_slice[j]);
							let style = null;
							let div = null;
							// 连接这一列与上一列
							if (piece_size.width_space > 0 && former_connect_request.has(row_index)) {
								let point_a = former_connect_request.get(row_index);
								for (let loop = 0; loop < point_a.length; ++loop) {
									div = document.createElement("span");
									// 隐藏章节的线不画，记录隐藏章节影响的所有连线
									if (chapter_type == "hide") {
										div.setAttribute("hidden", "true");
										hidden_array.push(target_panel.childElementCount);
									}
									offset.width = piece_size.width_space;
									offset.height = (offset_index - point_a[loop]) * offset.top_unit * offset.ratio;
									offset.deg = Math.atan(offset.height / offset.width);
									if (offset.deg == 90) {
										offset.hypotenuse = offset.height;
									}
									else {
										offset.hypotenuse = offset.width / Math.cos(offset.deg);
									}
									offset.deg *= 180 / Math.PI
									offset.hypotenuse = Math.abs(offset.hypotenuse);
									style = "width: " + offset.hypotenuse + "%;height:2px;transform:rotateZ(" + offset.deg + "deg);";
									style += "left:" + (offset.left_space + offset.left_unit * i - (offset.hypotenuse - offset.width) / 2 - piece_size.width_space) + "%;";
									style += "top:" + (offset.top_space + offset.top_unit * (point_a[loop] + offset_index) / 2) + "%;";
									div.setAttribute("style", style);
									target_panel.appendChild(div);
								}
							}
							// 向下一列发出请求
							if (data_slice[j + 2].length != 0) {
								for (let loop = 0; loop < data_slice[j + 2].length; ++loop) {
									let target = data_slice[j + 2][loop] - 1;
									let list = connect_request.get(target);
									if (list == null) {
										list = new Array();
									}
									list.push(offset_index);
									connect_request.set(target, list);
								}
							}
							
							div = document.createElement("div");
							// 隐藏章节的节点不画，记录隐藏章节节点
							if (chapter_type == "hide") {
								div.setAttribute("hidden", "true");
								hidden_array.push(target_panel.childElementCount);
								param.hidden_id_map.set(data_slice[j], hidden_array);
							}
							let p = document.createElement("p");
							if (chapter_type == "error") {
								p.style.color = "#e54";
								p.innerText = "未找到引用章节：" + data_slice[j];
							}
							// 锁定章节的名字隐藏，记录锁定章节节点
							else if (chapter_type == "lock") {
								div.setAttribute("locked", true);
								p.innerText = "锁定的章节";
								p.setAttribute("content", data_slice[j + 1]);
								locked_array.push(target_panel.childElementCount);
								// 如果该章节已解锁，就把数据放解锁map
								if (param.unlock_id_map.has(data_slice[j])) {
									param.unlock_id_map.set(data_slice[j], locked_array);
									param.locked_id_map.delete(data_slice[j]);
								}
								else {
									param.locked_id_map.set(data_slice[j], locked_array);
								}
							}
							else {
								p.innerText = data_slice[j + 1];
							}
							div.appendChild(background);
							div.appendChild(p);
							
							style = "width:" + piece_size.width + "%;height:" + piece_size.height + "%;";
							style += "left:" + (offset.left_space + offset.left_unit * i) + "%;";
							style += "top:" + (offset.top_space + offset.top_unit * offset_index) + "%;";
							div.setAttribute("style", style);
							target_panel.appendChild(div);
							first = true;
						}
						former_connect_request = connect_request;
						connect_request = new Map();
					}
					this.#chapter_view_param = param;
				}
				
				// 在原有的基础上重绘章节视图
				#repaintChapterRelationView() {
					let param = this.#chapter_view_param;
					let container = this.#components.chapter_view_content;
					if (container == null) {
						return;
					}
					for (let i = 0; i < container.childElementCount; ++i) {
						container.children[i].removeAttribute("hidden");
					}
					let self = this;
					let keys = Array.from(param.unlock_id_map.keys());
					for (let i = 0; i < keys.length; ++i) {
						let key = keys[i];
						let unlock_index = param.unlock_id_map.get(key);
						for (let j = 0; j < unlock_index.length; ++j) {
							let item = container.children[unlock_index[j]];
							let item2 = item.lastChild;
							if (item2.hasAttribute("content")) {
								item2.innerText = item2.getAttribute("content");
								item2.removeAttribute("content");
							}
							if (item.hasAttribute("locked")) {
								item.onclick = function() {
									self.showChapterView();
									self.clearContent();
									self.loadChapter(key);
									self.toNext(0);
								}
								item.removeAttribute("locked");
							}
						}
					}
					keys = Array.from(param.hidden_id_map.keys());
					for (let i = 0; i < keys.length; ++i) {
						// 锁定的隐藏章节不显示
						if (param.locked_id_map.has(keys[i])) {
							let hidden_index = param.hidden_id_map.get(keys[i]);
							for (let j = 0; j < hidden_index.length; ++j) {
								container.children[hidden_index[j]].setAttribute("hidden", true);
							}
						}
					}
				}
				
				#clearHistory() {
					this.#components.history_content.innerHTML = "";
					this.#components.history.children[1].removeAttribute("hidden");
					this.#history_param.update = true;
				}
				
				// 添加一条历史对话记录
				#addHistory(name, content) {
					let li = document.createElement("li");
					let h3 = document.createElement("h3");
					h3.innerText = name;
					let p = document.createElement("p");
					p.innerText = content;
					li.appendChild(h3);
					li.appendChild(p);
					this.#components.history_content.appendChild(li);
					if (this.#components.history_content.childElementCount > 80) {
						this.#components.history_content.firstChild.remove();
					}
					this.#components.history.children[1].setAttribute("hidden", true);
					this.#history_param.update = true;
				}
				
				popInfo(title, content, time) {
					// console.trace(title);
					this.#components.pop_note.children[0].innerText = title;
					this.#components.pop_note.children[1].innerText = content;
					if (this.#pop_note_param.thread == null) {
						this.#components.pop_note.removeAttribute("hidden");
					}
					else {
						clearTimeout(this.#pop_note_param.thread);
					}
					let self = this;
					this.#pop_note_param.thread = setTimeout(function() {
						self.#components.pop_note.setAttribute("hidden", true);
						self.#pop_note_param.thread = null;
					}, time);
				}
				
				logAudio(str) {
					// console.log("[音频] " + str);
				}
				
				logImage(str) {
					// console.log("[图片] " + str);
				}
				
			}
			
			// 单选面板
			class d_RadioPanel {
				// 本体dom元素
				#container = null;
				
				// 选中物体的顺序下标
				#select_item_index = -1;
				
				// 是否关联到其他面板的开放和隐藏
				#is_related = false;
				constructor(container) {
					this.#container = container;
				}
				
				// 关联到下一个兄弟元素内面板的开放和隐藏
				relateToRear(is_true) {
					this.#is_related = is_true;
				}
				
				// 增加一个物体到指定顺序位置
				addItem(item, index) {
					if (this.isIndexValid(index)) {
						this.#container.insertBefore(item, this.#container.children[index]);
					}
					else {
						this.#container.appendChild(item);
					}
				}
				
				// 移除指定顺序下标的物体
				removeItem(index) {
					this.#container.removeChild(this.#container.children[index]);
					if (index == this.#select_item_index) {
						this.#select_item_index = -1;
					}
				}
				
				// 选中指定顺序下标的物体
				selectItem(index) {
					this.clearSelect();
					if (!this.isIndexValid(index)) {
						return;
					}
					this.#select_item_index = index;
					let item = this.#container.children[index];
					item.setAttribute("selected", "true");
				
					// 如果关联到其他面板的展示和隐藏，just do it
					// 否则，就到此为止
					if (!this.#is_related) {
						return;
					}
					let radio_index = item.getAttribute("radio-index");
					let parent = this.#container.nextElementSibling;
					for (let i = 0; i < parent.childElementCount; ++i) {
						if (i == radio_index) {
							parent.children[i].removeAttribute("style");
							continue;
						}
						parent.children[i].style.display = "none";
					}
				}
				
				// 获取指定顺序下标的dom元素
				getItem(index) {
					if (!this.isIndexValid(index)) {
						return null;
					}
					return this.#container.children[index];
				}
				
				// 查找指定物体的顺序下标，返回-1表示不含该物体
				getItemIndex(that) {
					if (that == null) {
						return -1;
					}
					else if (that.parentNode != this.#container) {
						return -1;
					}
					let temp = that;
					let index = 0;
					while (temp.previousElementSibling) {
						++index;
						temp = temp.previousElementSibling;
					}
					return index;
				}
				
				// 改变指定顺序下标index物体的顺序位置到new_index
				setItemIndex(index, new_index) {
					if (!this.isIndexValid(index)) {
						return -1;
					}
					let append = false;
					if (new_index < 0) {
						new_index = 0;
					}
					else if (new_index >= this.#container.childElementCount - 1) {
						new_index = this.#container.childElementCount - 1;
						append = true;
					}
					if (index == new_index) {
						return -1;
					}
					if (new_index > index) {
						++new_index;
					}
					if (!append) {
						this.#container.insertBefore(this.#container.children[index], this.#container.children[new_index]);
					}
					else {
						this.#container.appendChild(this.#container.children[index]);
					}
					if (new_index > index) {
						--new_index;
					}
					if (this.#select_item_index == index) {
						this.#select_item_index = new_index;
					}
					return new_index;
				}
				
				// 获得控制的本体dom元素
				getObject() {
					return this.#container;
				}
				
				// 获得子物体的数量
				getCount() {
					return this.#container.childElementCount;
				}
				
				// 清空选择
				clearSelect() {
					if (this.isIndexValid(this.#select_item_index)) {
						let former = this.#container.children[this.#select_item_index];
						former.removeAttribute("selected");
					}
					this.#select_item_index = -1;
				}
				
				// 清空数据
				clear() {
					this.clearSelect();
					while (this.#container.firstChild) {
						this.#container.lastChild.remove();
					}
				}
				isIndexValid(index) {
					if (isNaN(index) || index < 0 || index >= this.#container.childElementCount) {
						return false;
					}
					return true;
				}
			}
			
			// 滚动窗口
			class d_ScrollPanel {
				#object = null;
				// 视口
				#viewport = null;
				// 内容物
				#content = null;
				// 滚动槽
				#scroll_slot_horizontal = null;
				#scroll_slot_vertical = null;
				// 滚动条
				#scroll_bar_horizontal = null;
				#scroll_bar_vertical = null;
				
				// 滚动条参数，百分比计
				#scroll_bar_param = {
					// 横竖滚动条的长宽、大小限制、百分比位置（因为leak）
					width_h: 50,
					width_v: 50,
					height: 150,
					min_width: 10,
					max_width: 50,
					percent_x: 0,
					percent_y: 0,
					// 画面实际位置
					content_pos_x: 0,
					content_pos_y: 50,
					// 画面实际位置限制
					content_limit_x: [0, 100],
					content_limit_y: [0, 100],
					// 允许离开滚动槽的范围占滚动条长度的比例
					leak: 2,
					// 滚动槽的长宽
					slot_width: 60,
					slot_height: 0.5,
					// 滚动槽相距底边的距离
					slot_float: 10,
					// 相对于滚动槽，实际可移动的比例
					slot_move_width_h: 90,
					slot_move_width_v: 90,
					// 通过拖拽画布可以赋予滚动条速度，让其自行移动
					speed_x: 0,
					speed_y: 0,
					// 速度损失比
					speed_lost: 0.6,
					speed_thread: null
				};
				
				// 鼠标是否离开了游戏区域
				// #blur = true;
				
				// 上次工作时的参数
				#work_param = {
					// 是否允许工作
					enable_x: false,
					enable_y: false,
					// 当前是否正在拖拽滚动条
					draging: false,
					// 类型，是拖滚动条还是拖背景
					type: 1,
					// 上次工作的时间戳
					last_time: 0,
					// 本次工作时，初始的鼠标位置
					mouse_x: 0,
					mouse_y: 0,
					// 本次工作的距离增量
					offset_x: 0,
					offset_y: 0
				};
				
				// 缩放参数
				#zoom_param = {
					enable: true,
					
					origin_width: 100,
					origin_height: 100,
					
					// 每1单位为0.1
					factor: 10,
					real_width: 100,
					real_height: 100
				};
				
				// 锚点
				#anchor = {
					h: "left",
					v: "top"
				}
				
				#update_interval = 10;
				
				#temp = 0;
				
				constructor(div, type) {
					this.#object = div;
					this.#viewport = div.getElementsByClassName("viewport")[0];
					this.#content = this.#viewport.getElementsByClassName("content")[0];
					let param = this.#scroll_bar_param;
					let aspect_ratio = this.#viewport.clinetHeight / this.#viewport.clientWidth;
					if (type % 2 == 0) {
						this.#scroll_slot_horizontal = document.createElement("div");
						this.#scroll_slot_horizontal.setAttribute("class", "scroll_slot");
						this.#scroll_slot_horizontal.setAttribute("style", "left:50%;top:unset;transform:translateX(-50%);width:" + param.slot_width + "%;height:" + param.slot_height + "em;border-radius:" + param.slot_height + "em;bottom:" + param.slot_float + "%;");
						this.#object.appendChild(this.#scroll_slot_horizontal);
						this.#scroll_bar_horizontal = document.createElement("div");
						this.#scroll_bar_horizontal.setAttribute("class", "scroll_bar");
						this.#scroll_bar_horizontal.setAttribute("style", "top:50%;height:" + param.height + "%;border-radius:" + (param.slot_height * param.height / 100) + "em;");
						this.#scroll_slot_horizontal.appendChild(this.#scroll_bar_horizontal);
					}
					if (type % 3 == 0) {
						this.#scroll_slot_vertical = document.createElement("div");
						this.#scroll_slot_vertical.setAttribute("class", "scroll_slot");
						this.#scroll_slot_vertical.setAttribute("style", "top:50%;left:unset;transform:translateY(-50%);width:" + param.slot_height + "em;height:" + param.slot_width + "%;border-radius:" + param.slot_width + "em;right:" + param.slot_float + "%;");
						this.#object.appendChild(this.#scroll_slot_vertical);
						this.#scroll_bar_vertical = document.createElement("div");
						this.#scroll_bar_vertical.setAttribute("class", "scroll_bar");
						this.#scroll_bar_vertical.setAttribute("style", "left:50%;width:" + param.height + "%;border-radius:" + (param.slot_height * param.height / 100) + "em;");
						this.#scroll_slot_vertical.appendChild(this.#scroll_bar_vertical);
					}
					
					param = this.#zoom_param;
					param.origin_width = 100 * this.#content.clientWidth / this.#viewport.clientWidth;
					param.origin_height = 100 * this.#content.clientHeight / this.#viewport.clientHeight;
					param.real_width = param.origin_width * param.factor / 10;
					param.real_height = param.origin_height * param.factor / 10;
					this.#zoom_param = param;
					
					let self = this;
					this.#viewport.onmousedown = function(event) {
						if (event.target != event.currentTarget) {
							return;
						}
						self.#work_param.draging = true;
						self.#work_param.type = 3;
					}
					this.#viewport.onwheel = function(event) {
						if (!self.#zoom_param.enable) {
							return;
						}
						self.zoom(event);
					}
					this.#content.onmousedown = function(event) {
						if (event.target != event.currentTarget) {
							return;
						}
						self.#work_param.draging = true;
						self.#work_param.type = 3;
						self.#scroll_bar_param.speed_x = 0;
						self.#scroll_bar_param.speed_y = 0;
						clearInterval(self.#scroll_bar_param.speed_thread);
						self.#scroll_bar_param.speed_thread = null;
					}
					if (this.#scroll_bar_horizontal != null) {
						this.#scroll_bar_horizontal.onmousedown = function(event) {
							if (event.target != event.currentTarget) {
								return;
							}
							self.#work_param.draging = true;
							self.#work_param.type = 1;
							self.#scroll_bar_param.speed_x = 0;
							self.#scroll_bar_param.speed_y = 0;
							clearInterval(self.#scroll_bar_param.speed_thread);
							self.#scroll_bar_param.speed_thread = null;
						}
					}
					if (this.#scroll_bar_vertical != null) {
						this.#scroll_bar_vertical.onmousedown = function(event) {
							if (event.target != event.currentTarget) {
								return;
							}
							self.#work_param.draging = true;
							self.#work_param.type = 2;
							self.#scroll_bar_param.speed_x = 0;
							self.#scroll_bar_param.speed_y = 0;
							clearInterval(self.#scroll_bar_param.speed_thread);
							self.#scroll_bar_param.speed_thread = null;
						}
					}
					this.#object.onmouseup = function() {
						self.#work_param.draging = false;
					}
					this.#object.onmouseleave = function() {
						// self.#blur = true;
						self.#work_param.draging = false;
					}
					this.#object.onmousemove = function(event) {
						// self.#blur = false;
						self.drag(event);
					}
					this.update();
					this.scrollTo("mm");
					// console.log(this.#viewport);
				}
				
				reset() {
					this.#zoom_param.factor = 10;
					this.update();
				}
				
				hideBar(type) {
					if (type == 0 && this.#scroll_slot_horizontal != null) {
						this.#scroll_slot_horizontal.setAttribute("hidden", "true");
					}
					if (type == 1 && this.#scroll_slot_vertical != null) {
						this.#scroll_slot_vertical.setAttribute("hidden", "true");
					}
				}
				
				setAnchor(horizontal, vertical) {
					if (horizontal != null) {
						this.#anchor.h = horizontal;
					}
					if (vertical != null) {
						this.#anchor.v = vertical;
					}
					this.update();
				}
				
				setZoom(enable) {
					this.#zoom_param.enable = enable;
				}
				
				scrollTo(pos) {
					if (typeof pos != "string" || pos.length != 2) {
						return;
					}
					let param = this.#scroll_bar_param;
					let target = {
						x: param.content_pos_x,
						y: param.content_pos_y
					};
					if (pos[0] == "l") {
						target.x = param.content_limit_x[0];
					}
					else if (pos[0] == "m") {
						target.x = (param.content_limit_x[0] + param.content_limit_x[1]) / 2;
					}
					else if (pos[0] == "r") {
						target.x = param.content_limit_x[1];
					}
					if (pos[1] == "t") {
						target.y = param.content_limit_y[0];
					}
					else if (pos[1] == "m") {
						target.y = (param.content_limit_y[0] + param.content_limit_y[1]) / 2;
					}
					else if (pos[1] == "b") {
						target.y = param.content_limit_y[1];
					}
					this.#moveToPos(target);
				}
				
				// 根据内容物计算滚动条的样式
				update() {
					let param = this.#scroll_bar_param;
					let percent = {
						x: param.max_width,
						y: param.max_width
					}
					if (this.#content.clientWidth != 0) {
						percent.x = this.#viewport.clientWidth / this.#content.clientWidth;
						this.#zoom_param.origin_width = 1000 / this.#zoom_param.factor / percent.x;
						this.#zoom_param.real_width = this.#zoom_param.origin_width * this.#zoom_param.factor / 10;
					}
					if (this.#content.clientHeight != 0) {
						percent.y = this.#viewport.clientHeight / this.#content.clientHeight;
						this.#zoom_param.origin_height = 1000 / this.#zoom_param.factor / percent.y;
						this.#zoom_param.real_height = this.#zoom_param.origin_height * this.#zoom_param.factor / 10;
					}
					param.width_h = percent.x * 100;
					param.width_v = percent.y * 100;
					if (param.width_h < param.min_width) {
						param.width_h = param.min_width;
					}
					else if (param.width_h > param.max_width) {
						param.width_h = param.max_width;
					}
					if (param.width_v < param.min_width) {
						param.width_v = param.min_width;
					}
					else if (param.width_v > param.max_width) {
						param.width_v = param.max_width;
					}
					if (this.#scroll_bar_horizontal != null) {
						this.#scroll_bar_horizontal.style.width = param.width_h + "%";
					}
					if (this.#scroll_bar_vertical != null) {
						this.#scroll_bar_vertical.style.height = param.width_v + "%";
					}
					this.#content.style.width = param.real_width + "%";
					this.#content.style.height = param.real_height + "%";
					percent.x = 100 * (this.#content.clientWidth - this.#viewport.clientWidth) / this.#viewport.clientWidth;
					param.content_limit_x[0] = 0;
					param.content_limit_x[1] = percent.x;
					percent.y = 100 * (this.#content.clientHeight - this.#viewport.clientHeight) / this.#viewport.clientHeight;
					param.content_limit_y[0] = 0;
					param.content_limit_y[1] = percent.y;
					param.slot_move_width_h = 100 - param.width_h + param.leak * 2;
					param.slot_move_width_v = 100 - param.width_v + param.leak * 2;
					
					// console.trace(param);
					// console.log(this.#work_param);
					// console.log(this.#zoom_param);
					if (this.#scroll_bar_horizontal == null || param.content_limit_x[0] >= param.content_limit_x[1]) {
						this.#work_param.enable_x = false;
						if (this.#scroll_bar_horizontal != null) {
							this.#scroll_bar_horizontal.setAttribute("hidden", true);
						}
						let anchor = this.#anchor.h;
						if (anchor == "left") {
							param.content_pos_x = 0;
							this.#content.style.left = "0%";
						}
						else if (anchor == "mid") {
							param.content_pos_x = (percent.x / 2);
							this.#content.style.left = -param.content_pos_x + "%";
						}
						else if (anchor == "right") {
							param.content_pos_x = percent.x;
							this.#content.style.left = -param.content_pos_x + "%";
						}
					}
					else {
						this.#work_param.enable_x = true;
						this.#scroll_bar_horizontal.removeAttribute("hidden");
					}
					if (this.#scroll_bar_vertical == null || param.content_limit_y[0] >= param.content_limit_y[1]) {
						this.#work_param.enable_y = false;
						if (this.#scroll_bar_vertical != null) {
							this.#scroll_bar_vertical.setAttribute("hidden", true);
						}
						let anchor = this.#anchor.v;
						if (anchor == "top") {
							param.content_pos_y = 0;
							this.#content.style.top = "0%";
						}
						else if (anchor == "mid") {
							param.content_pos_y = (percent.y / 2);
							this.#content.style.top = -param.content_pos_y + "%";
						}
						else if (anchor == "bottom") {
							param.content_pos_y = percent.y;
							this.#content.style.top = -param.content_pos_y + "%";
						}
					}
					else {
						this.#work_param.enable_y = true;
						this.#scroll_bar_vertical.removeAttribute("hidden");
					}
					this.#scroll_bar_param = param;
					
				}
				
				drag(event) {
					if (this.#viewport.clientWidth <= 0 || this.#viewport.clientHeight <= 0) {
						return;
					}
					let time = new Date().getTime();
					// 小于工作间隔，不允许加班
					if (time - this.#work_param.last_time < this.#update_interval) {
						return;
					}
					this.#calculateSpeed();
					if (!this.#work_param.draging) {
						this.#work_param.mouse_x = event.clientX;
						this.#work_param.mouse_y = event.clientY;
						return;
					}
					this.#work_param.last_time = time;
					this.#work_param.offset_x = event.clientX - this.#work_param.mouse_x;
					this.#work_param.offset_y = event.clientY - this.#work_param.mouse_y;
					
					let param = this.#scroll_bar_param;
					let dist = {
						x: 0,
						y: 0
					}
					if (this.#work_param.type == 1) {
						// 在视口移动1%相当于50%长度进度条在视口（而不是在滚动槽）移动2%
						dist.x = 10000 * this.#work_param.offset_x / this.#viewport.clientWidth / (param.slot_move_width_h * param.slot_width);
						// 进度条移动1%相当于地图移动1%
						dist.x *= (param.content_limit_x[1] - param.content_limit_x[0]);
						// console.log(dist.x);
					}
					else if (this.#work_param.type == 2) {
						// 在视口移动1%相当于50%长度进度条在视口（而不是在滚动槽）移动2%
						dist.y = 10000 * this.#work_param.offset_y / this.#viewport.clientHeight / (param.slot_move_width_v * param.slot_width);
						// 进度条移动1%相当于地图移动1%
						dist.y *= (param.content_limit_y[1] - param.content_limit_y[0]);
						// console.log(dist.x);
					}
					else if (this.#work_param.type == 3) {
						this.#scroll_bar_param.speed_x = -this.#work_param.offset_x * 100;
						this.#scroll_bar_param.speed_y = this.#work_param.offset_y * 100;
						dist.x = this.#scroll_bar_param.speed_x / this.#viewport.clientWidth;
						dist.y = -this.#scroll_bar_param.speed_y / this.#viewport.clientHeight;
					}
					this.#work(dist);
					this.#work_param.mouse_x = event.clientX;
					this.#work_param.mouse_y = event.clientY;
				}
				
				zoom(event) {
					let zoom_center = {
						x: 0,
						y: 0
					}
					if (document.fullscreenElement != this.#object.parentNode.parentNode) {
						zoom_center.x = event.pageX - this.#object.parentNode.parentNode.offsetLeft - this.#content.offsetLeft;
						zoom_center.y = event.pageY - this.#object.parentNode.parentNode.offsetTop - this.#content.offsetTop;
					}
					else {
						zoom_center.x = event.clientX - this.#content.offsetLeft;
						zoom_center.y = event.clientY - (screen.height - this.#viewport.clientHeight) / 2 - this.#content.offsetTop;
					}
					// console.log("==========");
					// console.log(zoom_center);
					zoom_center.x = 100 * zoom_center.x / this.#viewport.clientWidth;
					zoom_center.y = 100 * zoom_center.y / this.#viewport.clientHeight;
					// console.log(zoom_center);
					let param = this.#zoom_param;
					let factor_delta = {
						x: param.real_width,
						y: param.real_height,
					}
					if (event.wheelDelta > 0) {
						++param.factor;
					}
					else if (event.wheelDelta < 0) {
						--param.factor;
					}
					if (param.factor < 1) {
						param.factor = 1;
					}
					else if (param.factor > 20) {
						param.factor = 20;
					}
					param.real_width = param.origin_width * param.factor / 10;
					param.real_height = param.origin_height * param.factor / 10;
					this.#zoom_param = param;
					this.#content.style.width = param.real_width + "%";
					this.#content.style.height = param.real_height + "%";
					
					factor_delta.x = (param.real_width - factor_delta.x) / factor_delta.x;
					factor_delta.y = (param.real_height - factor_delta.y) / factor_delta.y;
					this.update();
					let dist = {
						x: zoom_center.x * factor_delta.x,
						y: zoom_center.y * factor_delta.y
					};
					this.#scroll_bar_param.speed_x = 0;
					this.#scroll_bar_param.speed_y = 0;
					this.#work(dist);
				}
				
				#work(canvas_dist) {
					let param = this.#scroll_bar_param;
					let pos = {
						x: 0,
						y: 0
					};
					let dist = canvas_dist;
					if (!this.#work_param.enable_x && !this.#work_param.enable_y) {
						return;
					}
					if (!this.#work_param.enable_x) {
						dist.x = 0;
					}
					if (!this.#work_param.enable_y) {
						dist.y = 0;
					}
					pos.x = param.content_pos_x + dist.x;
					pos.y = param.content_pos_y + dist.y;
					this.#moveToPos(pos);
				}
				
				#moveToPos(pos) {
					let param = this.#scroll_bar_param;
					
					if (!this.#work_param.enable_x) {
						pos.x = param.content_pos_x;
					}
					else if (pos.x < param.content_limit_x[0]) {
						pos.x = param.content_limit_x[0];
					}
					else if (pos.x > param.content_limit_x[1]) {
						pos.x = param.content_limit_x[1];
					}
					if (!this.#work_param.enable_y) {
						pos.y = param.content_pos_y;
					}
					else if (pos.y < param.content_limit_y[0]) {
						pos.y = param.content_limit_y[0];
					}
					else if (pos.y > param.content_limit_y[1]) {
						pos.y = param.content_limit_y[1];
					}
					
					param.content_pos_x = pos.x;
					param.content_pos_y = pos.y;
					param.percent_x = (pos.x - param.content_limit_x[0]) / (param.content_limit_x[1] - param.content_limit_x[0]);
					param.percent_y = (pos.y - param.content_limit_y[0]) / (param.content_limit_y[1] - param.content_limit_y[0]);
					// console.log(param);
					this.#scroll_bar_param = param;
					if (this.#scroll_bar_horizontal != null) {
						let bar_x = param.percent_x * param.slot_move_width_h + param.width_h / 2 - param.leak;
						this.#scroll_bar_horizontal.style.left = bar_x + "%";
					}
					if (this.#scroll_bar_vertical != null) {
						let bar_y = param.percent_y * param.slot_move_width_v + param.width_v / 2 - param.leak;
						this.#scroll_bar_vertical.style.top = bar_y + "%";
					}
					this.#content.style.left = -param.content_pos_x + "%";
					this.#content.style.top = -param.content_pos_y + "%";
				}
				
				#calculateSpeed() {
					let self = this;
					let param = this.#scroll_bar_param;
					let judge = param.speed_x != 0 || param.speed_y != 0;
					if (judge && param.speed_thread == null) {
						param.speed_thread = setInterval(function() {
							self.#calculateSpeed();
							if (self.#work_param.draging) {
								return;
							}
							let dist = {
								x: self.#scroll_bar_param.speed_x / 1000,
								y: -self.#scroll_bar_param.speed_y / 1000,
							};
							self.#work(dist);
						}, this.#update_interval);
					}
					else if (judge) {
						let scale = param.speed_lost * this.#update_interval / 1000;
						param.speed_x -= param.speed_x * scale;
						param.speed_y -= param.speed_y * scale;
						if (Math.abs(param.speed_x) < 100) {
							param.speed_x = 0;
						}
						if (Math.abs(param.speed_y) < 100) {
							param.speed_y = 0;
						}
					}
					// x和y都停下来
					else if (!judge) {
						clearInterval(param.speed_thread);
						param.speed_thread = null;
					}
					this.#scroll_bar_param = param;
				}
			}
			
			// 渲染器
			class d_HTML2Canvas {
				// 调试信息输出开关
				static debug_mode = false;
				
				// 渲染用的画布
				#canvas = null;
				#context = null;
				
				// 是否正在工作中
				#working = false;
				
				// 输出参数选项的UI控制器
				#output_radio = [null, null, null];
				
				// 渲染参数
				#render_param = {
					method: 1,
					type: 1,
					head_index: -1,
					rear_index: -1,
					head_offset: 0,
					rear_offset: 0,
					scale: 1
				};
				
				// 渲染结果
				#output = new Array();
				constructor() {
					this.#canvas = document.createElement("canvas");
					this.#context = this.#canvas.getContext('2d');
					this.#output_radio[0] = new d_RadioPanel(document.getElementById("output_data_1"));
					this.#output_radio[0].selectItem(0);
					this.#output_radio[1] = new d_RadioPanel(document.getElementById("output_data_2"));
					this.#output_radio[1].relateToRear(true);
					this.#output_radio[1].selectItem(0);
					this.#output_radio[2] = new d_RadioPanel(document.getElementById("output_data_3"));
					this.#output_radio[2].relateToRear(true);
					this.#output_radio[2].selectItem(1);
				}
				
				// 开始渲染
				takeScreenshot() {
					if (d_HTML2Canvas.debug_mode) {
						this.debugLog("渲染参数：" + this.getRenderParameter());
					}
					if (this.#render_param.type < 0) {
						if (d_HTML2Canvas.debug_mode) {
							this.debugLog("输出设置有误，请检查参数");
						}
						return;
					}
					let time = new Date();
					if (d_HTML2Canvas.debug_mode) {
						this.debugLog("开始渲染 " + time);
					}
					
					// 渲染时不允许再次进行渲染
					// new Promise(function (resolve, reject) {
						if (this.#working) {
							if (d_HTML2Canvas.debug_mode) {
								this.debugLog("正在处理中，请稍后");
							}
							return;
						}
						this.#working = true;
						// resolve();
					// });
					
					// 调整输出尺寸
					if (isNaN(this.#render_param.scale)) {
						this.#render_param.scale = 1;
					}
					else if (this.#render_param.scale < 0.5) {
						this.#render_param.scale = 0.5;
					}
					else if (this.#render_param.scale > 8) {
						this.#render_param.scale = 8;
					}
					this.#output = new Array();
					let target = document.getElementById("container");
					this.#ensureRenderRange(target)
					let render_counter = [0, 0, 0];
					
					// 真的开始渲染
					this.#render(target.children[0].children[0], 8, render_counter, 0, 0);
					if (this.#render_param.type == 2) {
						this.#render(document.getElementById("container_head"), 8, render_counter, 0, this.#render_param.head_offset *  this.#render_param.scale);
					}
					
					// 结束，拿到结果
					// console.log(this.#canvas.toDataURL());
					let img = new Image();
					img.src = this.#canvas.toDataURL();
					img.style.width = (this.#canvas.width / this.#render_param.scale) + "px";
					img.style.height = (this.#canvas.height / this.#render_param.scale) + "px";
					this.#context.clearRect(0, 0, this.#canvas.width, this.#canvas.height);
					let finish_time = new Date();
					if (d_HTML2Canvas.debug_mode) {
						this.debugLog("完成渲染 " + finish_time);
						let str = "渲染耗时约 " + ((finish_time.getTime() - time.getTime()) / 1000) + " 秒，";
						str += "渲染物体 " + render_counter[1] + " 个";
						this.debugLog(str);
					}
					
					this.#output = [img];
					
					// 按用户想法反馈结果
					if (this.#render_param.method == 1) {
						let preview = document.getElementById("picture_preview");
						while (preview.firstChild) {
							preview.lastChild.remove();
						}
						for (let i = 0; i < this.#output.length; ++i) {
							preview.appendChild(this.#output[i]);
						}
					}
					else {
						for (let i = 0; i < this.#output.length; ++i) {
							let link = document.createElement("a");
							link.download = download_prefix + "Output" + new Date().getTime() + i.toString();
							link.href = this.#output[i].src;
							link.click();
							link.remove();
						}
					}
					
					// 工作结束
					this.#working = false;
				}
				
				// 设置渲染参数
				setRenderParameter(param) {
					// 不允许渲染的过程中修改渲染参数
					if (this.#working) {
						if (d_HTML2Canvas.debug_mode) {
							this.debugLog("正在处理中，请稍后");
						}
						return;
					}
					
					// 输出方式
					if (param[0] != null) {
						this.#render_param.method = param[0];
						this.#output_radio[0].selectItem(param[0] - 1);
					}
					
					// 渲染元素范围
					if (param[1] != null) {
						this.#render_param.type = param[1];
						if (this.#render_param.type == 4) {
							let index = getSelectItemIndex();
							if (index < 0) {
								this.#render_param.type = -4;
							}
						}
						this.#output_radio[1].selectItem(param[1] - 1);
					}
					
					// 渲染屏幕范围
					if (param[2] != null) {
						param[2] = parseInt(param[2]);
						let index = parseInt(getSelectItemIndex());
						let offset = this.#render_param.rear_index - this.#render_param.head_index;
						// type置负阻止进入渲染流程
						if (index < 0) {
							if (this.#render_param.type == 4) {
								this.#render_param.type = -4;
							}
							index = this.#render_param.head_index;
						}
						else {
							if (this.#render_param.type == -4) {
								this.#render_param.type = 4;
							}
							this.#render_param.head_index = index;
						}
						if (param[2] < 0) {
							this.#render_param.rear_index = index + offset;
						}
						else {
							this.#render_param.rear_index = index + param[2];
						}
					}
					
					// 渲染尺寸
					if (param[3] != null) {
						let scale = 1;
						if (param[3] == 1) {
							scale = 0.3;
						}
						else if (param[3] == 2) {
							scale = 1;
						}
						else if (param[3] == 3) {
							scale = 3;
						}
						else if (param[3] == 4) {
							scale = 8;
						}
						this.#render_param.scale = scale;
						this.#output_radio[2].selectItem(param[3] - 1);
					}
				}
				
				// 获取渲染参数
				getRenderParameter() {
					let res = "输出方式：";
					if (this.#render_param.method == 1) {
						res += "预览";
					}
					else {
						res += "下载";
					}
					
					res += "，渲染类型："
					if (this.#render_param.type == 1) {
						res += "一图流";
					}
					else if (this.#render_param.type == 2) {
						res += "屏幕";
					}
					else if (this.#render_param.type == 3) {
						res += "限制";
					}
					else if (this.#render_param.type == 4) {
						res += "多个";
					}
					else if (this.#render_param.type == -4) {
						res += "多个（未正确选择条目）";
					}
					res += "，从条目 " + this.#render_param.head_index + " 到条目 " + this.#render_param.rear_index;
					res += "，顶部 " + this.#render_param.head_offset + "，底部 " + this.#render_param.rear_offset;
					res += "，渲染尺寸：" + this.#render_param.scale + "x";
					return res;
				}
				
				// 确定渲染的范围
				// 比如从第二项开始渲染，那么初始位置就要减去第一项的高度
				#ensureRenderRange(target) {
					target = target.children[0].children[0];
					let head = 0;
					let rear = target.childElementCount - 1;
					
					// 一图流
					if (this.#render_param.type == 1) {
						this.#render_param.head_offset = target.children[head].offsetTop - 20;
						this.#render_param.rear_offset = target.children[rear].offsetTop + target.children[rear].offsetHeight + 20;
					}
					
					// 屏幕渲染
					else if (this.#render_param.type == 2 || this.#render_param.type == 3) {
						let index = 0;
						for (index = 0; index < target.childElementCount; ++index) {
							if (target.children[index].offsetTop + target.children[index].offsetHeight > target.parentNode.scrollTop) {
								break;
							}
						}
						this.#render_param.head_offset = target.parentNode.scrollTop - 2;
						let top_offset = document.getElementById("container_head").offsetHeight;
						if (this.#render_param.type == 3) {
							this.#render_param.head_offset += top_offset;
						}
						this.#render_param.rear_offset = this.#render_param.head_offset + target.parentNode.offsetHeight;
						if (this.#render_param.type == 3) {
							this.#render_param.rear_offset -= top_offset;
						}
					}
					
					// 渲染多个条目
					else if (this.#render_param.type == 4) {
						head = this.#render_param.head_index;
						if (rear > this.#render_param.rear_index) {
							rear = this.#render_param.rear_index;
						}
						this.#render_param.head_offset = target.children[head].offsetTop - 20;
						this.#render_param.rear_offset = target.children[rear].offsetTop + target.children[rear].offsetHeight + 20;
					}
					this.#canvas.width = target.offsetWidth * this.#render_param.scale;
					this.#canvas.height = (this.#render_param.rear_offset - this.#render_param.head_offset) * this.#render_param.scale;
					this.#context.fillStyle = "#eee";
					this.#context.fillRect(0, 0, this.#canvas.width, this.#canvas.height);
				}
				
				// 递归渲染所有物体
				#render(item, depth, counter, base_offset_x, base_offset_y) {
					if (depth <= 0) {
						this.debugLogError("终止渲染：递归深度异常");
						return false;
					}
					--depth;
					let style = window.getComputedStyle(item);
					if (style.display == "none") {
						return true;
					}
					let cal_offset = false;
					if (item.getAttribute("class") == "item") {
						cal_offset = true;
						let index = counter[2];
						++counter[2];
						if (d_HTML2Canvas.debug_mode) {
							this.debugLog(">>> 条目 " + counter[2]);
						}
						if (this.#render_param.type == 2 || this.#render_param.type == 3) {
							if (item.offsetTop + item.offsetHeight < this.#render_param.head_offset) {
								return true;
							}
							else if (item.offsetTop > this.#render_param.rear_offset) {
								return true;
							}
						}
						if (this.#render_param.type == 4) {
							if (index < this.#render_param.head_index || index > this.#render_param.rear_index) {
								return true;
							}
						}
					}
					else if(item.getAttribute("class") == "talk_container") {
						cal_offset = true;
					}
					let border_width = parseInt(style.borderWidth.slice(0, -2)) * this.#render_param.scale;
					if (cal_offset) {
						base_offset_x += (item.offsetLeft) * this.#render_param.scale;
						base_offset_y += (item.offsetTop) * this.#render_param.scale;
					}
					else {
						this.#renderItem(item, style, counter, [base_offset_x, base_offset_y - this.#render_param.head_offset * this.#render_param.scale]);
					}
					if (item.firstChild != null) {
						for (let i = 0; i < item.childElementCount; ++i) {
							if (!this.#render(item.children[i], depth, counter, base_offset_x + border_width, base_offset_y + border_width)) {
								return false
							}
						}
					}
					return true;
				}
				
				// 渲染物体
				#renderItem(item, style, counter, base_offset) {
					if (d_HTML2Canvas.debug_mode) {
						++counter[0];
						this.debugLog("检查元素……（" + counter[0] + "）");
					}
					let render_name = null;
					
					let x = base_offset[0] + item.offsetLeft * this.#render_param.scale;
					let y = base_offset[1] + item.offsetTop * this.#render_param.scale;
					let width = item.offsetWidth * this.#render_param.scale;
					let height = item.offsetHeight * this.#render_param.scale;
					let border_radius = parseInt(style.borderRadius.slice(0, -2)) * this.#render_param.scale;
					// let padding_left =  parseInt(style.paddingLeft.slice(0, -2));
					// let padding_top =  parseInt(style.paddingTop.slice(0, -2));
					
					let str = style.transform;
					let degree = 0;
					if (str != "none") {
						str = str.split('(')[1].slice(0, -1).split(',');
						degree = [parseFloat(str[0]), parseFloat(str[1])];
						degree = Math.atan2(degree[1], degree[0]);
					}
					
					str = style.backgroundColor;
					let has_background = false;
					if (str != "none") {
						str = str.split(',');
						if (str.length == 4) {
							str = parseFloat(str[3].slice(0, -1));
							if (str != 0) {
								has_background = true;
							}
						}
						else {
							has_background = true;
						}
					}
					
					if (this.#render_param.type == 2 && item.getAttribute("id") == "container_head") {
						this.#renderRect(x, y, width, height, border_radius, style.backgroundColor);
						render_name = "顶栏";
					}
					if (has_background && item.tagName.toLowerCase() != "input") {
						this.#renderRect(x, y, width, height, border_radius, style.backgroundColor, degree);
						render_name = "(" + x + "," + y + ") 色块";
					}
					if (item.firstElementChild == null && item.innerText != "") {
						let color = style.color;
						let font_size = style.fontSize;
						font_size = parseInt(font_size.slice(0, -2));
						font_size = font_size * this.#render_param.scale
						let font = style.fontWeight + " " + font_size + "px 微软雅黑";
						let line_height = parseInt(style.lineHeight.slice(0, -2)) * this.#render_param.scale;
						let letter_spacing = parseInt(style.letterSpacing.slice(0, -2));
						
						let offset = (line_height + font_size) / 2;
						// this.#renderRect(x, y, 10, 1, 0, "#f66", 0);
						y += offset + 2 * this.#render_param.scale;
						this.#renderText(item.innerText, x, y, font, color, style.textAlign, width, line_height, letter_spacing);
						render_name = "(" + x + "," + y + ") 文字：";
						if (item.innerText.length >= 7) {
							render_name += item.innerText.substr(0, 6) + "……";
						}
						else {
							render_name += item.innerText;
						}
					}
					if (item.tagName.toLowerCase() == "img") {
						this.#renderImage(item.src, x, y, width, height, border_radius);
						render_name = "(" + x + "," + y + ") 图片";
					}
					if (item.tagName.toLowerCase() == "input") {
						let color = "#000";
						let font_size = 26 * this.#render_param.scale;
						let font = style.fontWeight + " " + font_size + "px 微软雅黑";
						let line_height = 30 * this.#render_param.scale;
						let letter_spacing = parseInt(style.letterSpacing.slice(0, -2));
						
						let offset = (line_height + font_size) / 2;
						this.#renderText(item.value, x, y + offset, font, color, "center", width, line_height, 1);
						render_name = "(" + x + "," + y + ") 输入框";
					}
					// else if (item.parentNode.getAttribute("class") == "talk_container") {
					// 	if (item.getAttribute("bubble") != null) {
					// 		this.#renderRect(x, y, width, height, border_radius, style.backgroundColor);
					// 	}
					// 	render_name = "气泡";
					// }
					// else if (item.getAttribute("class") == "talk_icon") {
					// 	this.#renderImage(item.src, x, y, width, height, border_radius);
					// 	render_name = "头像";
					// }
					// else if (item.getAttribute("class") == "talk_name") {
					// 	this.#renderText(item.innerText, x, y + 6 * this.#render_param.scale, font, color, style.textAlign, width, line_height);
					// 	render_name = "昵称";
					// }
					// else if (item.getAttribute("class") == "talk_prefix") {
					// 	this.#renderRect(x, y, width, height, border_radius, style.backgroundColor, 45);
					// 	render_name = "气泡";
					// }
					// else if (item.getAttribute("content-type") == "text") {
					// 	this.#renderText(item.innerText, x, y + 6 * this.#render_param.scale, font, color, style.textAlign, width, line_height);
					// 	render_name = "聊天：";
					// 	if (item.innerText.length >= 7) {
					// 		render_name += item.innerText.substr(0, 6) + "……";
					// 	}
					// 	else {
					// 		render_name += item.innerText;
					// 	}
					// }
					// else if (item.getAttribute("content-type") == "image") {
					// 	this.#renderImage(item.src, x, y, width, height, border_radius);
					// 	render_name = "图像";
					// }
					// else if (item.parentNode.getAttribute("content-type") == "audio") {
					// 	this.#renderRect(x, y, width, height, border_radius, style.backgroundColor);
					// 	render_name = "音频符号";
					// }
					// else if (item.getAttribute("content-type") == "audio_translate") {
					// 	this.#renderText(item.innerText, x, y + 6 * this.#render_param.scale, font, color, style.textAlign, width, line_height);
					// 	render_name = "语音转文字";
					// }
					
					if (d_HTML2Canvas.debug_mode && render_name != null) {
						++counter[1];
						this.debugLog("已渲染 " + render_name + "（" + counter[1] + "）");
					}
				}
				
				// 渲染矩形
				#renderRect(x, y, width, height, radius, color, deg) {
					let ctx = this.#context;
					ctx.fillStyle = color;
					this.#drawBaseRect(ctx, x, y, width, height, radius, deg);
					ctx.fill();
				}
				
				// 渲染文字
				#renderText(text, x, y, font, color, align, line_width, line_height, letter_spacing) {
					let ctx = this.#context;
					ctx.font = font;
					ctx.fillStyle = color;
					ctx.textBaseline = "ideographic";
					let text_line = "";
					let cur_length = 0;
					let cur_height = 0;
					let align_offset = 0;
					let increase = 0;
					for (let i = 0; i < text.length; ++i) {
						increase = ctx.measureText(text[i]).width;
						// 如果再加一个字就超了，将这行字进行渲染
						if (cur_length + increase >= line_width || text[i] == '\n') {
							if (align == "center") {
								align_offset = (line_width - cur_length) / 2;
							}
							cur_length = 0;
							for (let j = 0; j < text_line.length; ++j) {
								ctx.fillText(text_line[j], x + cur_length + align_offset, y + cur_height);
								increase = ctx.measureText(text_line[j]).width + letter_spacing * this.#render_param.scale;
								cur_length += increase;
							}
							text_line = "";
							cur_length = 0;
							cur_height += line_height;
						}
						if (text[i] != '\n') {
							text_line += text[i];
							cur_length += increase + letter_spacing * this.#render_param.scale;
						}
					}
					if (align == "center") {
						align_offset = (line_width - cur_length) / 2;
					}
					cur_length = 0;
					for (let j = 0; j < text_line.length; ++j) {
						ctx.fillText(text_line[j], x + cur_length + align_offset, y + cur_height);
						increase = ctx.measureText(text_line[j]).width + letter_spacing * this.#render_param.scale;
						cur_length += increase;
					}
				}
				
				// 渲染图像
				#renderImage(path, x, y, width, height, radius) {
					let ctx = this.#context;
					let img = new Image();
					let _object = this;
					img.src = path;
					img.onload = new Promise(function(resolve, reject) {
						ctx.save()
						_object.#drawBaseRect(ctx, x, y, width, height, radius);
						ctx.clip();
						ctx.drawImage(img, x, y, width, height);
						ctx.restore()
						resolve();
					});
					return;
				}
				
				// 绘制圆角矩形路径
				#drawBaseRect(ctx, x, y, width, height, radius, deg) {
					if (radius > width / 2) {
						radius = width / 2;
					}
					if (radius > height / 2) {
						radius = height / 2;
					}
					let points = [
						[x + radius, y],
						[x + width - radius, y],
						[x + width, y],
						[x + width, y + radius],
						[x + width, y + height - radius],
						[x + width, y + height],
						[x + width - radius, y + height],
						[x + radius, y + height],
						[x, y + height],
						[x, y + height - radius],
						[x, y + radius],
						[x, y],
						[x + radius, y]
					];
					if (deg != null && deg != 0) {
						// deg = deg / 180 * Math.PI;
						let mid_x = x + width / 2;
						let mid_y = y + height / 2;
						for (let loop = 0; loop < points.length; ++loop) {
							let x = points[loop][0];
							let y = points[loop][1];
							points[loop][0] = (x - mid_x) * Math.cos(deg) - (y - mid_y) * Math.sin(deg) + mid_x;
							points[loop][1] = (x - mid_x) * Math.sin(deg) + (y - mid_y) * Math.cos(deg) + mid_y;
						}
					}
					ctx.beginPath();
					ctx.moveTo(points[0][0], points[0][1]);
					for (let loop = 1; loop < points.length; loop += 3) {
						ctx.lineTo(points[loop][0], points[loop][1]);
						ctx.arcTo(points[loop + 1][0], points[loop + 1][1], points[loop + 2][0], points[loop + 2][1], radius);
					}
					ctx.closePath();
					return ctx;
				}
				debugLog(str) {
					console.log("[HTML2Canvas] " + str);
				}
				debugLogError(str) {
					console.error("[HTML2Canvas] " + str);
				}
			}
			
			class d_ScenePacker {
				static working = 0;
				
				#tip = null;
				
				#output_form = null;
				#waiting_path = new Map();
				#fulfilled_path = [];
				#success_count = 0;
				
				start() {
					if (d_ScenePacker.working == 0) {
						++d_ScenePacker.working;
					}
					else {
						return;
					}
					this.#tip = document.getElementById("render_output");
					this.logError("开始导出");
					
					database.update("talk", "type=6", "type=4");
					database.update("talk", "type=6", "type=5");
					database.update("talk", "type=8", "type=7");
					
					this.log("开始整理资源需求……");
					let count = 1;
					count = this.connectDatabase("talk", "type", d_DataEnum.MID_AUDIO, "param3", "aud/", count);
					count = this.connectDatabase("talk", "type", d_DataEnum.RIGHT_AUDIO, "param3", "aud/", count);
					count = this.connectDatabase("talk", "type", d_DataEnum.MID_IMAGE, "param1", "img/", count);
					count = this.connectDatabase("talk", "type", d_DataEnum.OPTION, "param3", "img/", count);
					count = this.connectDatabase("advanced_param", "name", "chapter_view_resource", "data", "img/", count);
					
					if (count == 1) {
						database.exportBinaryData("play", true);
					}
					else {
						this.listAllRequestFiles();
					}
					
					// this.logFileRequest(this.#audio_wait_path, this.#image_wait_path);
					// database.debug();
					
					// let count = this.#render_limit;
					// let self = this;
					// for (let i = 0; i < count; ++i) {
					// 	let index = i + 1;
					// 	setTimeout(function() {
					// 		self.#addIdleThread(index)
					// 	}, 1000);
					// }
				}
				
				connectDatabase(table_name, search_field, search_value, search_target, dir_prefix, count) {
					let data = database.select(table_name, "id," + search_target, search_field + "=" + search_value);
					for (let i = 0; i < data.length; ++i) {
						let t_data = data[i];
						let iplus = i + 1;
						let str = t_data[1] + "……( " + iplus + " /" + data.length + ")";
						if (t_data[1].trim() == "") {
							this.log("[跳过：空] " + str);
							continue;
						}
						t_data[1] = dir_prefix + t_data[1];
						if (!this.#waiting_path.has(t_data[1])) {
							this.log("[成功：首次] " + str);
							this.#waiting_path.set(t_data[1], count);
							++count;
						}
						else {
							this.log("[成功：重复] " + str);
						}
						// console.log(search_field + "=" + this.#waiting_path.get(t_data[1]));
						// console.log("id=" + t_data[0]);
						database.update(table_name, search_target + "=" + this.#waiting_path.get(t_data[1]), "id=" + t_data[0]);
						database.addRecord("resource", ["", ""]);
					}
					return count;
				}
				
				listAllRequestFiles() {
					this.#fulfilled_path = new Array(this.#waiting_path.size);
					let form = document.createElement("form");
					this.#output_form = form;
					this.#tip.appendChild(form);
					let div = document.createElement("div");
					let p = document.createElement("p");
					p.innerText = "批量上传";
					p.setAttribute("style", "margin-top: 30px; font-weight: bold;");
					div.appendChild(p);
					p = document.createElement("p");
					p.innerText = "请打开img文件夹或aud文件夹，系统会自动寻找同名文件并添加";
					div.appendChild(p);
					p = document.createElement("p");
					p.innerText = "请注意！这是敏感操作：请确保当前正在使用的编辑器来源正常";
					p.setAttribute("style", "color: #e54;");
					div.appendChild(p);
					let file = document.createElement("input");
					file.type = "file";
					file.webkitdirectory = true;
					file.directory = true;
					let self = this;
					file.onchange = function(event) {
						for (let i = 0; i < event.target.files.length; ++i) {
							let target = event.target.files[i];
							let path = target.webkitRelativePath || target.relativePath;
							if (self.#waiting_path.has(path)) {
								let index = self.#waiting_path.get(path);
								self.#fulfilled_path[index - 1] = target;
								form.children[index + 2].style.border = "1px dashed #5b6";
								form.children[index + 2].style.backgroundColor = "#cec";
								// console.log(form.children[index + 2])
								form.children[index + 2].children[1].value = null;
							}
						}
						file.files = null;
					}
					div.appendChild(file);
					form.appendChild(div);
					
					p = document.createElement("p");
					p.innerText = "单独上传";
					p.setAttribute("style", "font-weight: bold;");
					form.appendChild(p);
					p = document.createElement("p");
					p.innerText = "可在下方对单独的一个资源进行替换或补充（成功添加的资源呈现为绿色）";
					form.appendChild(p);
					let keys = Array.from(this.#waiting_path.keys());
					for (let i = 0; i < keys.length; ++i) {
						let index = i;
						div = document.createElement("div");
						// div.setAttribute("style", "margin: 10px 0;border:1px dashed #999;border-radius:9px;");
						div.setAttribute("class", "form");
						p = document.createElement("p");
						p.innerText = "资源：" + keys[i];
						file = document.createElement("input");
						file.type = "file";
						file.onchange = function(event) {
							if (event.target.files == null) {
								return;
							}
							self.#fulfilled_path[index] = event.target.files[0];
							form.children[index + 3].style.border = "1px dashed #5b6";
							form.children[index + 3].style.backgroundColor = "#cec";
						}
						file.name = "form_" + keys[i];
						div.appendChild(p);
						div.appendChild(file);
						form.appendChild(div);
					}
					
					p = document.createElement("p");
					p.innerText = "检查";
					p.setAttribute("style", "margin-top: 14px; font-weight: bold;");
					form.appendChild(p);
					p = document.createElement("p");
					p.innerText = "确保您已经添加所有的资源（成功添加的资源呈现为绿色），然后点击下方按钮开始打包";
					form.appendChild(p);
					p = document.createElement("p");
					p.innerText = "如果系统检查到您有资源缺失，会将对应项目以红色边框作为提示告知您，此时请检查上方资源需求列表";
					form.appendChild(p);
					let ul = document.createElement("ul");
					ul.setAttribute("class", "button_list");
					ul.setAttribute("style", "margin: 10px 0;");
					let li = document.createElement("li");
					li.innerText = "开始打包";
					li.onclick = function() {
						self.pack();
					};
					ul.appendChild(li);
					form.appendChild(ul);
					return form;
				}
				
				pack() {
					for (let i = 0; i < this.#fulfilled_path.length; ++i) {
						if (this.#fulfilled_path[i] == null) {
							// console.log(this.#fulfilled_path[i]);
							this.#output_form.children[i + 1].style.border = "1px solid #e54";
							this.#output_form.children[i + 1].style.backgroundColor = "";
							return;
						}
					}
					for (let i = 0; i < this.#fulfilled_path.length; ++i) {
						let index = i + 1;
						let path = this.#fulfilled_path[i].name;
						let reader = new FileReader();
						let self = this;
						reader.readAsDataURL(this.#fulfilled_path[i]);
						reader.onload = async function() {
							// console.log(index + 1);
							database.setRecord("resource", index, ["", reader.result]);
							await self.packSuccess("已完成文件" + path + "的整合");
						};
						reader.onerror = function() {
							self.packError("整合文件" + path + "时出错");
						};
					}
				}
				
				packSuccess(str) {
					++this.#success_count;
					this.log(str + "……(" + this.#success_count + "/" + this.#fulfilled_path.length + ")");
					if (this.#success_count == this.#fulfilled_path.length) {
						database.exportBinaryData("play", true);
					}
				}
				
				packError(str) {
					this.logError(str);
				}
				
				// #addIdleThread(index) {
				// 	// 有线程完成渲染，说明工作结束
				// 	// 判断自己是否为最后一个结束工作的线程
				// 	if (this.#render_done > 0) {
				// 		++this.#render_done;
				// 		this.#tryOutput(index);
				// 		this.logError("线程" + index + "：工作已完成！");
				// 		return;
				// 	}
				// 	this.log("启动" + index + "号线程");
				// 	let self = this;
				// 	setTimeout(function() {
				// 		self.#render(index)
				// 	}, 0);
				// }
				
				// #tryOutput(index) {
				// 	// 所有线程完成渲染
				// 	if (this.#render_done >= this.#render_limit) {
				// 		this.log("线程" + index + "：正在导出……");
				// 		database.exportBinaryData("play");
				// 		this.log("线程" + index + "：完成！");
				// 	}
				// }
				
				// #render(index) {
				// 	let type = 0;
				// 	let path = "";
					
				// 	// 先尝试渲染音频
				// 	if (this.#audio_wait_index < this.#audio_wait_path.length) {
				// 		type = 1;
				// 		path = this.#audio_wait_path[this.#audio_wait_index];
				// 		++this.#audio_wait_index;
				// 	}
				// 	// 再尝试渲染图片
				// 	else if (this.#image_wait_index < this.#image_wait_path.length) {
				// 		type = 2;
				// 		path = this.#image_wait_path[this.#image_wait_index];
				// 		++this.#image_wait_index;
				// 	}
					
				// 	// 没有新的工作
				// 	if (type == 0) {
				// 		++this.#render_done;
				// 		this.logError("线程" + index + "：工作已完成！");
				// 		let self = this;
				// 		self.#tryOutput(index);
				// 		return;
				// 	}
				// 	else if (type == 1) {
				// 		this.log("线程" + index + "：开始整合音频" + path);
				// 		this.#renderAudio(index, path);
				// 	}
				// 	else if (type == 2) {
				// 		this.log("线程" + index + "：开始整合图片" + path);
				// 		this.#renderImage(index, path);
				// 	}
				// }
				
				// #renderAudio(index, path) {
				// 	this.log("线程" + index + "：尝试连接本地音频文件");
				// 	let audio = document.createElement("audio");
				// 	audio.src = "./aud/" + path;
				// 	let self = this;
				// 	audio.onloadedmetadata = function() {
				// 		self.#renderAudio1(index, path, audio);
				// 	};
				// }
				
				// #renderAudio1(index, path, audio) {
				// 	this.log("线程" + index + "：开始录制音频，时长" + Math.round(audio.duration * 10) / 10 + "秒");
				// 	let self = this;
					
				// 	let context = new AudioContext();
				// 	let src = context.createMediaElementSource(audio);
				// 	let dest = context.createMediaStreamDestination();
				// 	src.connect(dest);
					
				// 	if (audio.offset) {
				// 		audio.currentTime = 0;
				// 	}
				// 	let recorder = new MediaRecorder(dest.stream, {audio: true, bitsPerSecond: 128000});
				// 	let audioChunks = [];
					
				// 	recorder.ondataavailable = function(event) {
				// 		if (event.data != null && event.data.size > 0) {
				// 			audioChunks.push(event.data);
				// 		}
				// 	};
					
				// 	recorder.onstop = function() {
				// 		let blob = new Blob(audioChunks, {type: "audio/wav"});
				// 		const reader = new FileReader();
						
				// 		reader.onload = function(event) {
				// 			let base64 = event.target.result;
				// 			let re_id = self.#audio_path_map.get(path);
				// 			database.addRecord("resource", [re_id, "audio", base64]);
				// 			self.log("线程" + index + "：已写入音频，资源id：" + re_id);
				// 			setTimeout(function() {
				// 				self.#addIdleThread(index)
				// 			}, 0);
				// 		};
				// 		reader.readAsDataURL(blob);
				// 	};
					
				// 	recorder.start();
				// 	audio.play();
					
				// 	audio.onpause = function() {
				// 		recorder.stop();
				// 	}
				// }
				
				// #renderImage(index, path) {
				// 	this.log("线程" + index + "：尝试连接本地图片文件");
				// 	// let img = document.createElement("img");
				// 	// this.#tip.appendChild(img);
				// 	if (path.trim().length != 0) {
				// 		let self = this;
				// 		let canvas = document.createElement("canvas");
				// 		// console.log("./img/" + path);
				// 		this.#temp(canvas, "./img/" + path);
				// 		this.#tip.appendChild(canvas);
				// 		let base64 = canvas.toDataURL("image/png");
						
				// 		let re_id = this.#image_path_map.get(path);
				// 		database.addRecord("resource", [re_id, "image", base64]);
				// 		this.log("线程" + index + "：已写入图片，资源id：" + re_id);
				// 		setTimeout(function() {
				// 			self.#addIdleThread(index)
				// 		}, 0);
						
				// 		// img.onload = function() {
				// 		// 	self.#renderImage1(index, path, img);
				// 		// }
				// 		// img.src = "./img/" + path;
				// 	}
				// }
				
				// #renderImage1(index, path, img) {
				// 	let self = this;
				// 	this.log("线程" + index + "：已连接本地图片文件：" + img.width + "x" + img.height);
				// 	if (img.width == 0 || img.height == 0) {
				// 		this.logError("线程" + index + "：文件错误！");
				// 		setTimeout(function() {
				// 			self.#addIdleThread(index)
				// 		}, 0);
				// 		return;
				// 	}
				// 	let ctx = canvas.getContext("2d");
				// 	canvas.width = img.width;
				// 	canvas.height = img.height;
				// 	ctx.drawImage(img, 0, 0, img.width, img.height);
				// 	ctx.fillRect(0, 0, 10, 10);
				// 	this.#tip.appendChild(canvas);
				// 	console.dir(canvas);
				// 	let base64 = canvas.toDataURL("image/png");
					
				// 	let re_id = this.#image_path_map.get(path);
				// 	database.addRecord("resource", [re_id, "image", base64]);
				// 	this.log("线程" + index + "：已写入图片，资源id：" + re_id);
				// 	setTimeout(function() {
				// 		self.#addIdleThread(index)
				// 	}, 0);
				// }
				
				// async #temp(canvas, path) {
				// 	let ctx = canvas.getContext("2d");
				// 	let img = new Image();
				// 	let _object = this;
				// 	img.src = path;
				// 	img.onload = await new Promise(function(resolve, reject) {
				// 		canvas.width = img.width;
				// 		canvas.height = img.height;
				// 		console.log(img);
				// 		ctx.drawImage(img, 0, 0, img.width, img.height);
				// 		resolve();
				// 	});
				// 	console.log("done");
				// }
				
				log(str) {
					let date = new Date();
					let p = document.createElement("p");
					p.innerText = date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds() + " " + str;
					this.#tip.appendChild(p);
				}
				
				logError(str) {
					let date = new Date();
					let p = document.createElement("b");
					p.innerText = date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds() + " " + str;
					this.#tip.appendChild(p);
				}
				
			}
			
			class d_VersionPublicity {
				#splash_introduction = null;
				#splash_timer = 0;
				#splash_time_node = [300, 1200, 2700, 3000, 3200, 3500, 4000];
				#up_text = "嗯聊 3.0";
				#down_text = "Tough Talk 3.0";
				#tail_text = "“绘声绘色”";
				constructor() {
					let cookie = sessionStorage.getItem("el_splash");
					this.#splash_introduction = document.getElementById("splash_introduction");
					if (cookie != null) {
						control_panel.resizePanel(1);
						this.#splash_introduction.remove();
						return;
					}
					sessionStorage.setItem("el_splash", 0);
					let _instance = this;
					this.#splash_timer = new Date().getTime();
					setInterval(function() {
						_instance.#playSplashIntroduction();
					}, 10);
					setTimeout(function() {
						_instance.#splash_introduction.children[0].setAttribute("selected", true);
					}, 800)
					setTimeout(function() {
						control_panel.resizePanel(1);
						_instance.#splash_introduction.remove();
					}, 5000);
				}
				#playSplashIntroduction() {
					let time = new Date().getTime() - this.#splash_timer;
					if (time < this.#splash_time_node[0]) {
						
					}
					else if (time < this.#splash_time_node[1]) {
						time -= this.#splash_time_node[0];
						let offset = this.#splash_time_node[1] - this.#splash_time_node[0];
						let index = Math.round(this.#up_text.length * time / offset);
						this.#splash_introduction.children[1].innerText = this.#up_text.substring(0, index);
						index = Math.round(this.#down_text.length * time / offset);
						this.#splash_introduction.children[2].innerText = this.#down_text.substring(0, index);
					}
					else if (time < this.#splash_time_node[2]) {
					}
					else if (time < this.#splash_time_node[3]) {
						time -= this.#splash_time_node[2];
						let offset = this.#splash_time_node[3] - this.#splash_time_node[2];
						let index = Math.round(this.#up_text.length * (1 - time / offset));
						this.#splash_introduction.children[1].innerText = this.#up_text.substring(0, index);
						index = Math.round(this.#down_text.length * (1 - time / offset));
						this.#splash_introduction.children[2].innerText = this.#down_text.substring(0, index);
						
					}
					else if (time < this.#splash_time_node[4]) {
						
					}
					else if (time < this.#splash_time_node[5]) {
						this.#splash_introduction.children[1].setAttribute("selected", true);
						this.#splash_introduction.children[1].innerText = this.#tail_text;
					}
				}
			}
			
			class d_Tool {
				static splitString(str, match) {
					if (typeof str != "string" || typeof match != "string") {
						return str;
					}
					else if (str.trim().length == 0 || match.length != 1) {
						return str;
					}
					let index = 0;
					let pardon = false;
					let replace_str = "";
					let res = [];
					for ( ; index < str.length; ) {
						// 反斜杠后一个字符视为普通字符
						if (!pardon && str[index] == '\\') {
							pardon = true;
							replace_str += str.substring(0, index);
							str = str.substring(index + 1);
							index = 0;
							continue;
						}
						if (str[index] == match && !pardon) {
							replace_str += str.substring(0, index);
							res.push(replace_str);
							str = str.substring(index + 1);
							replace_str = "";
							index = 0;
						}
						else {
							++index;
						}
						pardon = false;
					}
					if (index > 0) {
						replace_str += str.substring(0, index);
					}
					res.push(replace_str);
					return res;
				}
				static escapeString(str, match) {
					if (typeof str != "string" || typeof match != "string") {
						return str;
					}
					else if (str.trim().length == 0 || match.length != 1) {
						return str;
					}
					let res = "";
					for (let index = 0; index < str.length; ++index) {
						// 需要转义的字符
						if (str[index] == match || str[index] == '\\') {
							res += "\\";
						}
						res += str[index];
					}
					return res;
				}
			}
			function collapse_node(that) {
				that.parentNode.nextElementSibling.style.display = "none";
				that.setAttribute("onclick", "expand_node(this)");
				that.innerText = "+";
			}
			function expand_node(that) {
				that.parentNode.nextElementSibling.style.display = null;
				that.setAttribute("onclick", "collapse_node(this)");
				that.innerText = "-";
			}
			function setSelectItemIndex() {
				return output_tool.setRenderParameter([null, null, -1, null]);
			}
			function getSelectItemIndex() {
				return control_panel.getSelectItemIndex();
			}
			function setContainerPosition(left, right) {
				let container = document.getElementById("container");
				if (left == null) {
					container.style.marginLeft = "auto";
				}
				else {
					container.style.marginLeft = left + "px";
				}
				if (right == null) {
					container.style.marginRight = "auto";
				}
				else {
					container.style.marginRight = right + "px";
				}
			}
			function setContainerType(type) {
				control_panel.setSimulateMode(type);
			}
			function selectRadio(that, index) {
				let parent = that.parentNode;
				that.setAttribute("selected", null);
				for (let i = 0; i < parent.childElementCount; ++i) {
					if (parent.children[i] != that) {
						parent.children[i].removeAttribute("selected");
					}
				}
				if (index == null) {
					return;
				}
				parent = parent.nextElementSibling;
				parent.children[index].removeAttribute("style");
				for (let i = 0; i < parent.childElementCount; ++i) {
					if (i != index) {
						parent.children[i].setAttribute("style", "display: none;");
					}
				}
			}
			function selectCheckbox(that, judge, index) {
				let parent = that.parentNode;
				let visible = true;
				if (judge != null) {
					visible = judge;
				}
				else if (that.getAttribute("selected") == "true") {
					that.removeAttribute("selected");
					visible = false;
				}
				else {
					that.setAttribute("selected", "true");
				}
				if (index == null) {
					return;
				}
				parent = parent.nextElementSibling;
				if (visible) {
					parent.children[index].removeAttribute("style");
				}
				else {
					parent.children[index].setAttribute("style", "display: none;");
				}
			}
			function exportScene() {
				control_panel.exportAsGame();
			}
			function switch_debug_mode(index, that) {
				let is_true = true;
				if (index == 1) {
					d_Database.debug_mode = !d_Database.debug_mode;
					is_true = d_Database.debug_mode;
					if (is_true) {
						document.getElementById("database").style.display = "initial";
						document.getElementById("database").style.wordBreak = "break-all";
					}
					else {
						document.getElementById("database").style.display = "none";
						document.getElementById("database").style.wordBreak = "break-all";
					}
				}
				else if (index == 2) {
					d_ControlPanel.debug_mode = !d_ControlPanel.debug_mode;
					is_true = d_ControlPanel.debug_mode;
				}
				else if (index == 3) {
					d_ViewPanel.debug_mode = !d_ViewPanel.debug_mode;
					is_true = d_ViewPanel.debug_mode;
				}
				else if (index == 4) {
					d_HTML2Canvas.debug_mode = !d_HTML2Canvas.debug_mode;
					is_true = d_HTML2Canvas.debug_mode;
				}
				if (is_true) {
					that.setAttribute("selected", true);
					console.log("开启控制台输出");
				}
				else {
					that.removeAttribute("selected");
					console.log("关闭控制台输出");
				}
			}
		</script>
	</head>
	<body style="background-color: #fff;" onclick="if (event.target == event.currentTarget) control_panel.clearSelect()">
		<div id="scene_container" class="hidden">
			<div>
				<div id="scene_background"></div>
				<div id="scene_sound"></div>
				<div class="talk_base"></div>
				<div class="talk_name">名字</div>
				<div class="talk_container">[想说些什么呢？]</div>
				<div id="scene_ui"></div>
				<div id="scene_option"></div>
				<div id="scene_chapter_view" hidden>
					<div class="viewport">
						<div class="content" style="position: absolute;"></div>
					</div>
					<p>作者未设置章节视图</p>
				</div>
				<div id="scene_history" hidden>
					<div class="viewport" style="width: 100%; height:80%; overflow: visible;">
						<div class="content" style="position: relative; width: 100%;">
							<ul class="talk_history"></ul>
						</div>
					</div>
					<p>暂无历史记录</p>
				</div>
				<ul id="scene_tool">
					<li onclick="scene_panel.fullScreen()">全屏</li>
					<li onclick="scene_panel.showChapterView()">进度</li>
					<li onclick="scene_panel.showHistory()">历史</li>
					<li onclick="scene_panel.autoPlay(1)">自动播放</li>
					<li onclick="scene_panel.autoPlay(4)">快进</li>
					<li onclick="scene_panel.downloadProgress()">下载存档</li>
					<li onclick="scene_panel.showCover(true)">主界面</li>
				</ul>
				<div id="scene_cover">
					<ul>
						<li style="margin-bottom: 4%;"><button onclick="scene_panel.newBeginning();">新的开始</button></li>
						<li style="margin-bottom: 0; font-size: 2em; color: #fb2; font-weight: bold;"></li>
						<li style="margin-bottom: 6%; font-size: 1em; color: #999; font-weight: bold;"></li>
						<li style="margin-bottom: 4%;"><button onclick="scene_panel.loadProgress();">从缓存读取存档</button></li>
						<li><p>从文件读取存档</p></li>
						<li style="margin-bottom: 4%;"><input type="file" onchange="scene_panel.loadProgressFile(this)" /></li>
						<li><button onclick="scene_panel.fullScreen();">全屏</button></li>
						<li hidden><button onclick="scene_panel.hideCover();">返回</button></li>
					</ul>
				</div>
				<div id="scene_pop_note" hidden>
					<h3></h3><p></p>
				</div>
			</div>
		</div>
		<div id="container">
			<div id="container_content"><div onclick="if (event.target == event.currentTarget) control_panel.clearSelect()"></div></div>
			<div id="container_head"><input style="text-align: center;" type="text" value="名称" /></div>
		</div>
		<div id="picture_preview"></div>
		<div id="template" style="display: none;">
			<div class="item" type=1 onclick="control_panel.selectItem(this)" side="left">
				<img class="talk_icon" />
				<div class="talk_prefix"></div>
				<div class="talk_name">未命名</div>
				<div class="talk_container">
					<div bubble><div content-type="text">编辑文字</div></div>
				</div>
			</div>
			<div class="item" type=2 onclick="control_panel.selectItem(this)" side="right">
				<img class="talk_icon" />
				<div class="talk_prefix"></div>
				<div class="talk_name">未命名</div>
				<div class="talk_container">
					<div bubble><div content-type="text">编辑文字</div></div>
				</div>
			</div>
			<div class="item" type=3 onclick="control_panel.selectItem(this)" side="mid">
				<div class="talk_container">
					<div><div content-type="text">编辑文字</div></div>
				</div>
			</div>
			<div class="item" type=4 onclick="control_panel.selectItem(this)" side="left">
				<img class="talk_icon"></img>
				<div class="talk_name">未命名</div>
				<div class="talk_container">
					<div><img content-type="image" /></div>
				</div>
			</div>
			<div class="item" type=5 onclick="control_panel.selectItem(this)" side="right">
				<img class="talk_icon"></img>
				<div class="talk_name">未命名</div>
				<div class="talk_container">
					<div><img content-type="image" /></div>
				</div>
			</div>
			<div class="item" type=6 onclick="control_panel.selectItem(this)" side="mid">
				<div class="talk_container">
					<div><img content-type="image" /></div>
				</div>
			</div>
			<div class="item" type=7 onclick="control_panel.selectItem(this)" side="left">
				<img class="talk_icon" />
				<div class="talk_prefix"></div>
				<div class="talk_name">未命名</div>
				<div class="talk_container">
					<div bubble><div content-type="audio"><div></div></div><div content-type="audio_duration">1"</div></div><br />
					<div bubble><div content-type="audio_translate">编辑翻译</div></div>
				</div>
			</div>
			<div class="item" type=8 onclick="control_panel.selectItem(this)" side="right">
				<img class="talk_icon" />
				<div class="talk_prefix"></div>
				<div class="talk_name">未命名</div>
				<div class="talk_container">
					<div bubble><div content-type="audio"><div></div></div><div content-type="audio_duration">1"</div></div><br />
					<div bubble><div content-type="audio_translate">编辑翻译</div></div>
				</div>
			</div>
			<div class="item" type=9 onclick="control_panel.selectItem(this)" side="mid">
				<div class="talk_container">
					<div><div style="margin-right: 10px;">♪</div><div content-type="text">音乐名称</div></div>
				</div>
			</div>
			<div class="item" type=10 onclick="control_panel.selectItem(this)" side="mid">
				<div class="talk_container">
					<div><div content-type="option"><div>编辑选项</div></div></div>
				</div>
			</div>
		</div>
		<div id="control" type=0>
			<div draggable="true" style="width: 32px; height: 32px; background-color: #fb2; border-radius: 20px; position: absolute; left: -16px; top: -16px; cursor: move;"></div>
			<div id="control_container" class="scroll_container">
				<h3 id="debug_panel" style="background-color: #fffa; position: absolute; overflow: hidden;">未在编辑</h3>
				<hr style="margin: 80px 0 0; border: #fb2 1px solid;" />
				<h2>常规</h2>
				<div style="width: 100%;">
					<h3>编辑<button onclick="expand_node(this)">+</button></h3>
					<div style="display: none;">
						<p>角色</p>
						<div class="scroll_container" style="width: 100%; min-height: 50px; max-height: 400px;">
							<p>未添加角色</p>
							<ul id="char_case" class="char_case"></ul>
						</div>
						<p>内容</p>
						<ul id="data_item_type_input" class="button_list">
							<li onclick="control_panel.setItemType(this, 1)" radio-index=0 selected>左文字</li>
							<li onclick="control_panel.setItemType(this, 2)" radio-index=0>右文字</li>
							<li onclick="control_panel.setItemType(this, 3)" radio-index=0>旁白</li>
							<li onclick="control_panel.setItemType(this, 4)" radio-index=1>左图片</li>
							<li onclick="control_panel.setItemType(this, 5)" radio-index=1>右图片</li>
							<li onclick="control_panel.setItemType(this, 6)" radio-index=1>场景图片</li>
							<li onclick="control_panel.setItemType(this, 7)" radio-index=2>左语音</li>
							<li onclick="control_panel.setItemType(this, 8)" radio-index=2>右语音</li>
							<li onclick="control_panel.setItemType(this, 9)" radio-index=2>背景音乐</li>
							<li onclick="control_panel.setItemType(this, 10)" radio-index=3>选项</li>
						</ul>
						<div>
							<div>
								<h4>文本内容<span>对话</span><span>场景</span></h4>
								<textarea name="data_talk_input_1" onchange="control_panel.setItemData(1, this.value)" type="text" maxlength="200"></textarea>
								<span class="note">
									<p>*注释</p>
									<p>不多于200字</p>
								</span>
							</div>
							<div style="display: none;">
								<h4>资源路径<span>对话</span><span>场景</span></h4>
								<input name="data_talk_input_1" onchange="control_panel.setItemData(1, this.value)" type="text" maxlength="200" />
								<img name="data_talk_preview_1" style="width: 60px; height: 60px; vertical-align: middle;">
								<span class="note">
									<p>*注释</p>
									<p>路径为./img/+此框输入内容，需要带上图片格式</p>
									<p>此项为空时，对该图层的图片进行清空</p>
								</span>
								<h4>图片大小<span>对话</span></h4>
								<input name="data_talk_input_2" onchange="control_panel.setItemData(2, this.value)" type="number" value="0" />
								<span class="note">
									<p>*注释</p>
									<p>整数，&lt50不生效</p>
								</span>
								<h4>适应方式<span>场景</span></h4>
								<select name="data_talk_input_3" onchange="control_panel.setItemData(3, this.value)" type="list">
									<option value="null">未选择</option>
									<option value="origin">原尺寸</option>
									<option value="fill">拉伸以铺满全屏幕</option>
								</select>
								<span class="note">
									<p>*注释</p>
									<p>选择原尺寸时，画框基础大小为1920x1080，图片随画框实际大小的缩放而缩放</p>
								</span>
								<h4>图层号<span>场景</span></h4>
								<input name="data_talk_input_4" onchange="control_panel.setItemData(4, this.value)" type="number" value="0" />
								<span class="note">
									<p>*注释</p>
									<p>数字越高显示优先级越高，同一个图层的图片会按先后顺序进行覆盖</p>
									<p>当值小于0时，将对所有图层的图片进行覆盖</p>
								</span>
								<h4>过渡时间<span>场景</span></h4>
								<input name="data_talk_input_5" onchange="control_panel.setItemData(5, this.value)" type="number" value="0" />
								<span class="note">
									<p>*注释</p>
									<p>整数，单位毫秒</p>
								</span>
								<h4>对齐方式<span>场景</span></h4>
								<select name="data_talk_input_6" onchange="control_panel.setItemData(6, this.value)" type="list">
									<option value="">未选择</option>
									<option value="lt">左上</option>
									<option value="ct">中上</option>
									<option value="rt">右上</option>
									<option value="lm">左中</option>
									<option value="cm">中心</option>
									<option value="rm">右中</option>
									<option value="lb">左下</option>
									<option value="cb">中下</option>
									<option value="rb">右下</option>
								</select>
								<span class="note">
									<p>*注释</p>
									<p>同时影响图像中心锚点</p>
								</span>
							</div>
							<div style="display: none;">
								<h4>文字描述<span>对话</span><span>场景</span></h4>
								<textarea name="data_talk_input_1" onchange="control_panel.setItemData(1, this.value)" type="text" maxlength="200"></textarea>
								<span class="note">
									<p>*注释</p>
									<p>不多于200字</p>
									<p>1.当选择左语音/右语音时，需要等待用户点击以跳过文字动画、进入下一幕</p>
									<p>2.当选择背景音乐时，此项文字不显示，自动立刻进入下一幕</p>
								</span>
								<h4>语音时长<span>对话</span></h4>
								<input name="data_talk_input_2" onchange="control_panel.setItemData(2, this.value)" type="number" value="0" />
								<span class="note">
									<p>*注释</p>
									<p>整数，单位秒，1~60</p>
								</span>
								<h4>资源路径<span>场景</span></h4>
								<input name="data_talk_input_3" onchange="control_panel.setItemData(3, this.value)" type="text" maxlength="200" />
								<audio name="data_talk_preview_3" style="vertical-align: bottom;" controls></audio>
								<span class="note">
									<p>*注释</p>
									<p>路径为./aud/+此框输入内容，需要带上音频格式，支持的音频格式有wav、mp3等，支持的格式将可以通过点击播放键进行播放</p>
									<p>我们建议您使用mp3存储背景音乐，因为这样文件的大小不至于过大</p>
									<p>此项为空时，对该音轨的音频进行清空</p>
								</span>
								<h4>音轨号<span>场景</span></h4>
								<input name="data_talk_input_4" onchange="control_panel.setItemData(4, this.value)" type="number" value="0" />
								<span class="note">
									<p>*注释</p>
									<p>同一个音轨的音频会按先后顺序进行覆盖</p>
									<p>当值小于0时，将对所有音轨的音频进行覆盖</p>
								</span>
								<h4>过渡时间<span>场景</span></h4>
								<input name="data_talk_input_5" onchange="control_panel.setItemData(5, this.value)" type="number" value="0" />
								<span class="note">
									<p>*注释</p>
									<p>整数，单位毫秒</p>
								</span>
								<h4>循环<span>场景</span></h4>
								<input name="data_talk_input_6" onchange="control_panel.setItemData(6, this.checked)" type="checkbox" />
								<span>未选择</span>
								<span class="note">
									<p>*注释</p>
									<p>当值为“未选择”：请点击来选择；当值为“是”：无限循环；当值为“否”：不循环</p>
								</span>
							</div>
							<div style="display: none;">
								<h4>文字描述<span>场景</span></h4>
								<textarea name="data_talk_input_1" onchange="control_panel.setItemData(1, this.value)" type="text" maxlength="200"></textarea>
								<span class="note">
									<p>*注释</p>
									<p>1.不多于200字</p>
									<p>2.使用英文分号“;”来隔开文字，这些分割后的文字将按顺序应用为选项的描述</p>
								</span>
								<h4>选项个数<span>场景</span></h4>
								<input name="data_talk_input_2" onchange="control_panel.setItemData(2, this.value)" type="number" value="1" />
								<span class="note">
									<p>*注释</p>
									<p>整数，1~4</p>
								</span>
								<h4>资源路径<span>场景</span></h4>
								<input name="data_talk_input_3" onchange="control_panel.setItemData(3, this.value)" type="text" maxlength="200" />
								<img name="data_talk_preview_3" style="width: 180px; height: 60px; vertical-align: middle;">
								<span class="note">
									<p>*注释</p>
									<p>注意：若<b>此项为空</b>，则当进行到此处时，将<b>自动顺序执行</b>所有选项；自动执行时，若一个选项不满足<b>选项条件</b>，则该选项会被<b>忽略</b></p>
									<p>1.路径为./img/+此框输入内容，需要带上图片格式</p>
									<p>2.图片会以“原尺寸”的适应方式载入场景</p>
									<p>3.所有的选项按钮均使用该图片资源</p>
								</span>
								<h4>变量修饰<span>场景进阶</span></h4>
								<input name="data_talk_input_4" onchange="control_panel.setItemData(4, this.value)" type="text" maxlength="200" />
								<span class="note">
									<p>*注释</p>
									<p>不多于200字</p>
									<p>如果您不明白怎么填，可以将这一栏空着</p>
									<p>先进行章节跳转判断，后进行变量修饰</p>
									<p>1.格式为<b>[变量名][操作符][整数/变量名]</b></p>
									<p>2.变量名只允许使用英文、下划线、中文进行组合；操作符只能有一个</p>
									<p>3.允许的操作符有：赋值=（将右值赋予左边）、加算+、减算-、乘算*、除算/、取模%、取随机数~（从0和右值构成的范围中随机取一个整数，包含两端）；如果运算后出现小数，数量级小于0.01的部分进行四舍五入，随后按去尾法取整</p>
									<p>4.推荐使用英文字母+下划线的方式进行命名，比如“A队得分”可以命为“a_score”；当然您也可以直接使用中文进行命名</p>
									<p>5.如果这个变量是您首次提出的，它的初始值将被默认为0</p>
									<p>6.修饰格式参考：score=5表示将score的值置为5；score*2表示将score的值乘以2；score-cost表示将score的值减去cost的值</p>
									<p>7.有多少个选项，就需要有多少个修饰，相邻的不同修饰使用英文分号“;”来隔开</p>
									<p>8.例如<b>score=1;score=2</b>表示选择第一个选项时，将score的值置为1；选择第二个选项时，将score的值置为2</p>
								</span>
								<h4>章节跳转<span>场景</span></h4>
								<input name="data_talk_input_5" onchange="control_panel.setItemData(5, this.value)" type="text" maxlength="200" />
								<span class="note">
									<p>*注释</p>
									<p>不多于200字</p>
									<p>先进行章节跳转判断，后进行变量修饰</p>
									<p>1.格式为<b>[章节序号1];[章节序号2];……</b></p>
									<p>2.每个选项可以跳转到指定的章节，您需要通过“章节序号”来标识跳转的章节，“章节序号”在 常规>章节>列表 中可以看到，是章节名称前的数字</p>
									<p>3.为了使每个选项可以正确地跳转至对应的章节，请使用英文分号“;”来隔开不同的章节序号</p>
									<p>4.这些跳转目标将被顺序地应用到选项上，因此请保证选项数目和跳转章节序号的数目一致，以使得每个选项都有它的去处</p>
									<p>5.跳转格式参考：<b>7;8;9</b>表示第1、2、3个选项分别跳转至7、8、9这三个章节</p>
									<p>进阶1.格式为：<b>[跳转语句1];[跳转语句2];……</b>，多个[跳转语句]使用英文分号“;”隔开，每个跳转语句顺序对应一个选项</p>
									<p>进阶2.其中，[跳转语句]的格式为<b>[跳转子语句1],[跳转子语句2],……</b>，多个[跳转子语句]使用英文逗号“,”隔开</p>
									<p>进阶3.其中，[跳转子语句]的格式为<b>[章节序号](=[变量名][判断符][整数/变量名])</b>，圆括号“()”内是选填参数</p>
									<p>进阶4.支持的判断符有：等于=、!不等于（英文感叹号）、&lt小于、>大于、&lt=小于等于、>=大于等于</p>
									<p>进阶5.多个[跳转子语句]的条件被满足时，第一个条件被满足的[跳转子语句]会直接触发章节跳转</p>
									<p>进阶6.没有[跳转子语句]被满足时，会<b>出错</b></p>
									<p>进阶7.跳转格式参考：<b>1=a_score=b_score,2=a_score>b_score,3;5</b></p>
									<p>假设正在进行一个比赛，A队队员问队长：“想要提前结束比赛吗？”，此时跳出两个选项：“结束”、“不结束”。如果选择“结束”就开始判断A队的分数和B队的分数谁更高：</p>
									<p>假设a_score=9，b_score=9，显然两队平局；于是根据跳转子语句<b>1=a_score=b_score</b>跳转到1号章节（平局结束）</p>
									<p>假设a_score=9，b_score=3，显然A队赢了；但是不满足跳转子语句<b>1=a_score=b_score</b>，于是查看下一个子语句<b>2=a_score>b_score</b>；发现满足条件，跳转到2号章节（胜利结束）</p>
									<p>假设a_score=3，b_score=9，显然A队输了；但是不满足前两个跳转子语句，查看最后一个子语句的时候，发现无论如何都满足条件（因为没有条件）；于是跳转到3号章节（失败结束）</p>
									<p>假设子语句1的三个条件都不被满足（在这个例子中是不可能的），那么会<b>出错</b></p>
									<p>在这个例子中，因为子语句1和2已经把A队能赢和平局的情况排除了，所以子语句3写<b>3=a_score&ltb_score</b>的效果和单写一个章节序号的效果是相同的</p>
									<p>假设选择选项“不结束”，就无条件直接进入5号章节（继续比赛）</p>
								</span>
								<h4>选项条件<span>场景进阶</span></h4>
								<input name="data_talk_input_6" onchange="control_panel.setItemData(6, this.value)" type="text" maxlength="200" />
								<span class="note">
									<p>*注释</p>
									<p>不多于200字</p>
									<p>如果您不明白怎么填，可以将这一栏空着</p>
									<p>只有当条件被满足时，该选项才会出现在场景中</p>
									<p>1.格式为<b>[条件1];[条件2];……</b>，每个条件对应一个选项</p>
									<p>2.其中，[条件]为空表示无条件出现，[条件]的格式为<b>[变量名][判断符][整数/变量名]</b></p>
									<p>3.详细内容请参考章节跳转进阶部分，不同点在于，本栏条件无需等于号“=”起头</p>
								</span>
								</b>
							</div>
						</div>
						<p>操作</p>
						<ul class="button_list">
							<li onclick="control_panel.addItem()">发送</li>
							<li onclick="control_panel.changeItemIndex(-1)">*上移一项</li>
							<li onclick="control_panel.changeItemIndex(1)">*下移一项</li>
							<li onclick="control_panel.removeItem()">删除此项</li>
						</ul>
						<span class="note">
							<p>*注释</p>
							<p>使用移动对话功能时，若您的对话条目数量超过约20万条（由CPU性能决定），可能会开始有卡顿感</p>
							<p>上述性能测试由CPU:intel i5-11400F完成</p>
						</span>
						<p>视图位置</p>
						<ul class="button_list">
							<li onclick="setContainerPosition(20, null);selectRadio(this);">左</li>
							<li onclick="setContainerPosition(300, null);selectRadio(this);">偏左</li>
							<li onclick="setContainerPosition(null, null);selectRadio(this);" selected>中</li>
							<li onclick="setContainerPosition(null, 300);selectRadio(this);">偏右</li>
							<li onclick="setContainerPosition(null, 20);selectRadio(this);">右</li>
						</ul>
						<p>模拟</p>
						<ul class="button_list">
							<li onclick="setContainerType(0);selectRadio(this);" selected>无</li>
							<li onclick="setContainerType(1);selectRadio(this);">屏幕</li>
							<!-- <li onclick="setContainerType(2);selectRadio(this);">场景</li> -->
						</ul>
					</div>
					<h3>角色<button onclick="expand_node(this)">+</button></h3>
					<div style="display: none;">
						<p>操作</p>
						<ul class="button_list">
							<li onclick="control_panel.addCharacter(null, true)">增加</li>
							<li onclick="control_panel.removeCharacter(true)">删除</li>
						</ul>
						<p>头像（路径为./img/下）</p>
						<input id="data_char_path_input" onchange="control_panel.setCharacterData([this.value, null], true)" type="text" />
						<img style="width: 60px; height: 60px; vertical-align: middle;">
	<!-- 					<p>添加方式二（不推荐）</p>
						<input id="char_file" type="file" /> -->
						<p>名称</p>
						<input id="data_char_name_input" onchange="control_panel.setCharacterData([null, this.value], true)" type="text" />
					</div>
					<h3>章节<button onclick="expand_node(this)">+</button></h3>
					<div style="display: none;">
						<p>操作</p>
						<ul class="button_list">
							<li onclick="selectRadio(this,0);" selected>增加</li>
							<li onclick="selectRadio(this,1);">加载</li>
							<li onclick="selectRadio(this,2);">编辑</li>
							<li type="red" onclick="selectRadio(this,3);">删除</li>
						</ul>
						<div>
							<div class="form">
								<h4>名称</h4>
								<input name="form_data" type="text" />
								<ul class="button_list">
									<li onclick="control_panel.addChapter(this.parentNode.parentNode)">确认</li>
								</ul>
							</div>
							<div class="form" style="display: none;">
								<h4>序号</h4>
								<input name="form_data" type="number" value="1" />
								<p style="color: #999; font-size: 18px;">序号：下方“列表”中，章节名字前的数字</p>
								<ul class="button_list">
									<li onclick="control_panel.loadChapter(this.parentNode.parentNode, this.parentNode.parentNode.nextElementSibling)">确认</li>
								</ul>
							</div>
							<div class="form" style="display: none;">
								<h4>名称</h4>
								<input name="form_data" type="text" />
								<h4>章节类型</h4>
								<input name="form_data" type="checkbox" /><span style="margin-right: 30px;">起始</span>
								<input name="form_data" type="checkbox" /><span>隐藏</span>
								<p style="color: #999; font-size: 18px;">您最多只能将一个章节设置为起始章节。更换起始章节时无需取消现有的起始章节，系统会自动保留最新设置的起始章节，并去掉其他章节的起始属性</p>
								<ul class="button_list">
									<li onclick="control_panel.editChapter(this.parentNode.parentNode)">确认修改</li>
								</ul>
							</div>
							<div class="form" style="display: none;">
								<h4>输入“delete”以确认删除</h4>
								<input name="form_data" type="text" />
								<p style="color: #999; font-size: 18px;">注意：您必须保留至少一个章节</p>
								<ul class="button_list">
									<li onclick="control_panel.deleteChapter(this.parentNode.parentNode)">确认</li>
								</ul>
							</div>
						</div>
						
						<p>列表</p>
						<div class="scroll_container" style="width: 100%; min-height: 50px; max-height: 400px;">
							<ul id="chapter_case"></ul>
						</div>
					</div>
					<h3>高级参数<button onclick="expand_node(this)">+</button></h3>
					<div style="display: none;">
						<div class="form">
							<h4>作品命名空间</h4>
							<input name="form_data" type="text" />
							<span class="note">
								<p>*注释</p>
								<p>一串由英文和下划线（可不带下划线）组成的文字，当您的作品与其他人重名时，系统将据此判断是否是同一份作品</p>
							</span>
							<h4>作品名称</h4>
							<input name="form_data" type="text" />
							<span class="note">
								<p>*注释</p>
								<p>作品的名称</p>
							</span>
							<h4>作品版本</h4>
							<input name="form_data" type="number" min="0" value="0" />
							<span class="note">
								<p>*注释</p>
								<p>数字</p>
								<p>通常来说，用户的一份存档文件只能应用到一份作品中</p>
								<p>特别地，如果作品命名空间、作品名称、作品作者都相同时，用户可通过您的高版本作品将低版本的存档转化为高版本的存档</p>
								<p>您可以通过增加版本数进行内容拓展（DLC），如此一来，您的用户无需重新完成这份作品的低版本部分，而可以直接游玩新内容</p>
							</span>
							<h4>作者</h4>
							<input name="form_data" type="text" />
							<span class="note">
								<p>*注释</p>
								<p>如果您想署名的话</p>
							</span>
							<h4>章节视图</h4>
							<textarea name="form_data"></textarea>
							<span class="note">
								<p>*注释</p>
								<p>格式：<b>[列元素1];[列元素2];[列元素3];……</b></p>
								<p>章节视图通过列划分来形成横向的线性结构。为区分开不同的列，您需要使用英文分号“;”来隔开不同的列元素</p>
								<p>[列元素]格式：<b>[行元素1],[行元素2],[行元素3],……</b></p>
								<p>章节视图的每一列通过行划分来确定排布模式。为区分开不同的行，您需要使用英文逗号“,”来隔开不同的行元素</p>
								<p>[行元素]格式：<b>[章节序号],[章节描述],[后向连接位次]</b></p>
								<p>行元素的三个参数同样通过英文逗号“,”分隔，请注意只在它们之间加上分隔符。</p>
								<p>每一个行元素都是一个您想展示的章节节点，因此，您需要通过<b>[章节序号]</b>来告知系统这一个节点会跳转到哪一章，通过<b>[后向连接位次]</b>来告知系统，这一个节点与其后一列的第几个行元素相连</p>
								<p>为了告诉用户这一节点讲述了什么，以供他们确定这是否是他们想要的目标，您需要填写<b>[章节描述]</b>。该内容会直接显示在节点之上。</p>
								<p>[后向连接位次]格式：<b>[位次1].[位次2].[位次3]. ……</b></p>
								<p>有时候您可能需要使一个节点连接到其后的多个节点，此时需要使用英文句号“.”将它们分开；该分隔符<b>无需转义</b>即可作为文本使用</p>
								<p><b>转义</b></p>
								<p>如果您想使用英文分号“;”或英文逗号“,”作为个性化输入内容而非分隔符，通常来说这是不允许的。不过，<b>仅在此处</b>允许您使用反斜杠“\”（注意不是正斜杠“/”）对上述特殊符号进行转义</p>
								<p>对于所有反斜杠后的第一个字符，系统会将其视作普通的字符。譬如“\,”会被视作“,”，而单独的“,”会被视作分隔符。</p>
								<p>如果您想在文本中使用英文分号“;”或反斜杠“\”，就请在其前面再加上<b>一个</b>反斜杠（\;和\\）；如果是英文逗号“,”，则需要在前面加上<b>三个</b>反斜杠（\\\,）</p>
							</span>
							<h4>章节视图节点图片</h4>
							<input name="form_data" type="text" />
							<span class="note">
								<p>*注释</p>
								<p>一张作为节点的图片，格式同其他图片</p>
							</span>
							<ul class="button_list" style="margin-bottom: 100px;">
								<li onclick="control_panel.setAdvancedParam(this.parentNode.parentNode)">确认修改</li>
							</ul>
							<ul class="button_list">
								<li onclick="control_panel.loadAdvancedParam(this.parentNode.parentNode)">载入参数</li>
								<li onclick="control_panel.randomAdvancedParam(this.parentNode.parentNode)">填入示范性参数1</li>
							</ul>
						</div>
					</div>
					<h3>数据<button onclick="expand_node(this)">+</button></h3>
					<div style="display: none;">
						<p>导出</p>
						<ul class="button_list">
							<li onclick="database.exportBinaryData(null, true)">下载数据</li>
						</ul>
						<p>导入</p>
						<ul class="button_list">
							<input onchange="database.importDataFromBinaryFile(this);" type="file" />
						</ul>
						<p>保存</p>
						<ul class="button_list">
							<li onclick="control_panel.autoSave();selectCheckbox(this);">自动保存至临时储存（每3分钟）</li>
						</ul>
						<p>临时储存</p>
						<ul class="button_list">
							<li onclick="database.readDataFromDB();selectCheckbox(this.parentNode.previousElementSibling.previousElementSibling.children[0], false)">从indexedDB中载入数据</li>
							<li><b style="font-weight: normal; text-decoration: line-through;">清空localStorage数据</b></li>
						</ul>
						<p style="color: #999; font-size: 18px;">注意：临时储存仅供<b>不小心关闭网页或刷新网页</b>后进行数据恢复，请使用 常规>数据>导出>下载数据 进行保存</p>
					</div>
					<h3>输出<button onclick="expand_node(this)">+</button></h3>
					<div style="display: none;">
						<p>打包内容</p>
						<ul class="button_list">
							<li onclick="selectRadio(this, 0)"><b style="font-weight: normal; text-decoration: line-through;">对话</b></li>
							<li onclick="selectRadio(this, 1)" selected>场景</li>
						</ul>
						<div>
							<div style="display: none;">
								<span class="note">
									<p>*声明</p>
									<p>在当前版本及以往版本的稳定性测试中发现此功能在部分情况存在异常，具体原因与浏览器安全策略有关</p>
									<p>如果出现异常，请尝试刷新网页或关闭并重新打开浏览器</p>
									<p>如果问题无法得到解决，那就<b>无法得到解决</b></p>
								</span>
								<p>方式</p>
								<ul id="output_data_1" class="button_list">
									<li onclick="output_tool.setRenderParameter([1, null, null, null])">预览</li>
									<li onclick="output_tool.setRenderParameter([2, null, null, null])">下载</li>
								</ul>
								<p>截断</p>
								<ul id="output_data_2" class="button_list">
									<li onclick="output_tool.setRenderParameter([null, 1, null, null])" radio-index=-1 selected>一图流</li>
									<li onclick="output_tool.setRenderParameter([null, 2, null, null])" radio-index=0>当前屏幕</li>
									<li onclick="output_tool.setRenderParameter([null, 3, null, null])" radio-index=0>当前屏幕，仅内容</li>
									<li onclick="output_tool.setRenderParameter([null, 4, null, null])" radio-index=1>多个</li>
								</ul>
								<div>
									<div>
										<p style="color: #999; font-size: 18px;">在 常规>编辑 内开启“屏幕模拟”</p>
									</div>
									<div style="display: none;">
										<span style="margin-left: 16px; font-size: 18px; color: #666;">数量：</span>
										<input onchange="output_tool.setRenderParameter([null, null, this.value, null])" type="number" value="0" />
										<p style="color: #999; font-size: 18px;">输出包含当前选中条目在内的指定数量的条目，向下计数</p>
										<p style="color: #999; font-size: 18px;">（一时间没想到怎么描述，不知道有没有建议）</p>
									</div>
								</div>
								<p>尺寸（数字越大图片越大，缩小到小尺寸越清晰）</p>
								<ul id="output_data_3" class="button_list">
									<li onclick="output_tool.setRenderParameter([null, null, null, 1])" radio-index=0>0.3x（不推荐）</li>
									<li onclick="output_tool.setRenderParameter([null, null, null, 2])" radio-index=1 selected>1x</li>
									<li onclick="output_tool.setRenderParameter([null, null, null, 3])" radio-index=-1>3x</li>
									<li onclick="output_tool.setRenderParameter([null, null, null, 4])" radio-index=2>8x（不推荐）</li>
								</ul>
								<div>
									<div style="display: none;">
										<p style="color: #999; font-size: 18px;">选这个，真不是整活吗？</p>
									</div>
									<div>
										<p style="color: #999; font-size: 18px;">有时候图片会有锯齿感，如有，请选后一个</p>
									</div>
									<div style="display: none;">
										<p style="color: #999; font-size: 18px;">请注意：这可能花费很长时间</p>
									</div>
								</div>
								<p>最后<span style="font-size: 14px; color: #0002;">，雨停了，让我们</span></p>
								<ul class="button_list">
									<li onclick="output_tool.takeScreenshot()">开始<span style="font-size: 14px; color: #0002;">吧</span></li>
								</ul>
							</div>
							<div>
								<p>开始</p>
								<p style="color: #999; font-size: 18px;"><b style="color: #e54;">请注意：</b>一旦开始，我们会将该数据文件的所有<b>通过文件路径引用的数据（图片等）</b>转化为存储在数据文件内的<b>资源</b>。</p>
								<p style="color: #999; font-size: 18px;">这一过程是<b>不可逆的</b>，并且任何数据文件只能进行一次，因此，建议先进行<b>数据导出</b>以备份作品。</p>
								<ul class="button_list">
									<li onclick="selectCheckbox(this, null, 0);">我已知晓上述内容的含义</li>
								</ul>
								<div>
									<ul class="button_list" style="display: none;">
										<li onclick="exportScene()">开始</li>
									</ul>
								</div>
							</div>
						</div>
					</div>
					<h3>开发者<button onclick="expand_node(this)">+</button></h3>
					<div style="display: none;">
						<p id="version_info" style="margin: 0 10px;">嗯聊v3.0.0</p>
						<p style="margin: 0 10px;">于2024.6.29</p>
						<p style="margin: 0 10px; user-select: text;">@WDDDDD</p>
						<p style="margin: 0 10px 10px; user-select: text;"><a href="https://github.com/hyacinthlet/ToughTalk.git" target="_blank" style="color: #fb2">前往github</a></p>
						<p style="margin: 0 10px 20px; user-select: text;"><a href="https://www.wjx.cn/vm/tUHuw5J.aspx#" target="_blank" style="color: #fb2">填写使用反馈/获取新版本</a></p>
						<p style="margin: 0 10px 20px;">修改后请保留版权说明</p>
						<ul class="button_list">
							<li onclick="selectRadio(this, 0);" selected>3.0.0</li>
							<li onclick="selectRadio(this, 1);">2.0.0</li>
						</ul>
						<div>
							<div>
								<div class="form" style="margin-bottom: 10px;">
									<p style="margin: 0 0 5px; font-weight: bold;">参与者</p>
									<p style="margin: 0;">感谢<b style="font-weight: bold; color: #fb2;">@落雨</b>对该版本的贡献。</p>
									<p style="margin: 0;">此外，感谢其余共1位测试员对该版本的贡献。</p>
								</div>
								<div class="form">
									<p style="margin: 0 0 5px; font-weight: bold;">其他链接</p>
									<p style="margin: 0; user-select: text;">百度贴吧：<a href="https://tieba.baidu.com/p/9067718395" target="_blank" style="color: #fb2">https://tieba.baidu.com/p/9067718395</a></p>
									<p style="margin: 0; user-select: text;">百度贴吧：<a href="https://tieba.baidu.com/p/9067740599" target="_blank" style="color: #fb2">https://tieba.baidu.com/p/9067740599</a></p>
								</div>
							</div>
							<div style="display: none;">
								<p style="margin: 0 10px;">其他链接</p>
								<p style="margin: 0 10px 20px; user-select: text;">百度贴吧：<a href="https://tieba.baidu.com/p/9017914820" target="_blank" style="color: #fb2">https://tieba.baidu.com/p/9017914820</a></p>
								<ul class="button_list">
									<li onclick="switch_debug_mode(1, this)">数据库debug模式</li>
									<li onclick="switch_debug_mode(2, this)">控制面板debug模式</li>
									<li onclick="switch_debug_mode(3, this)">视图debug模式</li>
									<li onclick="switch_debug_mode(4, this)">渲染debug模式</li>
								</ul>
								<div id="database" style="display: none; word-wrap: break-all; user-select: text;"></div>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
		<div id="splash_introduction">
			<div style="background-image: linear-gradient(-90deg, #e990, #e78f91, #ffc59b, #e1e166, #92da95, #91dad5, #8892ec, #d9a9da, #dad0);"></div>
			<p style="font-weight: bold; margin: 0; text-align: center;"></p>
			<p style="font-weight: bold; margin: 0; text-align: center;"></p>
		</div>
	</body>
</html>
